[{"content":"译者序 这篇文章翻译自 SystemTap 项目中 uprobes.txt 文件，此文件描述了 Uprobes 的概念、工作原理、限制等内容。用途跟 Kprobes 一样，用来追踪运行在用户态的应用程序的。看提交历史，这个功能在 2012 年才提交到 Linux 内核中。\n文章最后提供的例子，可以修改来玩一玩。\n注：因为水平有限，文中难免存在遗漏或者错误的地方。如有疑问，建议直接阅读原文。\n概念：Uprobes、Return 探针 Uprobes 能够动态的介入应用程序的任意函数，采集调试和性能信息，且不引起混乱。你可以在任意地址上，指定断点命中时调用的内核函数。\n目前，用户态探针有两种类型： uprobes 和 uretprobes（也叫 return 探针）。可以在应用程序的虚拟地址空间的任意指令上插入 uprobe 。 当用户函数返回的时候触发 return 探针。后续内容会详细的讨论这两类探针的细节。\nregister_uprobe() 注册函数设定要探测的进程，探针插入的位置，以及命中探针时调用什么回调函数。\n通常，基于 Uprobes 的探测工具是被打包成内核模块。最简单的内核模块，初始化函数安装（\u0026ldquo;注册\u0026rdquo;）一个或多个探针，而后在 exit 函数中注销。其实还可以在响应其他事件中注册或注销探针。例如：\n 探针回调函数自身可以注册或注销探针 可以创建 Utrace 回调函数来注册或注销探针，探测特定的进程什么时候派生子进程、克隆线程、执行、进入系统调用、接收信号、退出等等。参考 Documentation/utrace.txt。  Uprobe 是怎么工作的？ 当一个 uprobe 被注册后，Uprobes 会创建一个被探测指令的副本，停止被探测的应用程序，用断点指令替换被探测指令的首字节（在 i386 和 x86_64 上是 int3），之后让应用程序继续运行。（在插入断点的时候，Uprobes 使用与 ptrace 使用的相同的 copy-on-write 机制，这样断点也只影响那个进程，不会影响其他运行相同程序的进程。甚至是被探测的指令在共享库中也一样。）\n当 CPU 命中断点指令的时候，发生了一个 trap，CPU 用户模式的寄存器都被保存起来，产生了一个 SIGTRAP 信号。Uprobes 拦截 SIGTRAP 信号，找到关联的 uprobe。然后，用 uprobe 结构体和先前保存的寄存器地址调用与 uprobe 关联的回调函数。这个回调函数可能会阻塞，但要记住回调函数执行期间，被探测的线程一直是停止的。\n接下来，Uprobes 会单步执行被探测指令的副本，之后会恢复被探测的程序，让它在探测点之后的指令处继续执行。（实际上单步执行原始指令会更简单，但之后，Uprobes 必须移除断点指令。这在多线程应用程序中会引起问题。比如，当另一个线程执行过探测点的时会打开一个时间窗口。）\n被单步执行的指令副本存储在每个进程的\u0026quot;单步跳出（SSOL）区域\u0026quot;中，它是由 Uprobes 在每个被探测进程的地址空间中创建的很小的 VM 区域。\nUtrace 的作用 当先前被取消探测的进程上又注册一个探针的时候，Uprobes 用 Utrace 为进程中每个线程建立了一个追踪\u0026quot;引擎\u0026rdquo;。Uprobes 使用 Utrace \u0026ldquo;静默\u0026quot;机制，在插入或移除断点之前停止所有线程。Utrace 在被探测进程的生命周期中（fork, clone, exec, exit），通知 Uprobes 断点和单步执行陷阱以及其他感兴趣的事件。\nReturn 探针怎么工作的？ 当你调用 register_uretprobe() 函数的时候，Uprobes 在函数的入口处创建一个 uprobe 。当调用被探测函数的时候命中这个探针，Uprobes 会保存 return 地址的一个副本，然后用\u0026quot;蹦床\u0026quot;的地址替换 return 地址 —— 一段包含一个断点指令代码。\n当被探测的函数执行它的 return 指令时，控制转移到蹦床，命中断点。Uprobes 的蹦床回调函数调用与 uretprobe 关联的回调函数，然后把已保存的指令指针设置为已保存的 return 地址，再然后就从 trap 返回后的地方恢复执行。\n蹦床存储在 SSOL 区域中。\npid to determine which thread has hit the probepoint. -- 多线程应用 Uprobes 支持多线程应用的探测。Uprobes 在被探测的应用中没有线程数量的限制。\n在单个进程中的所有线程，使用相同的文本页，所以进程中的每个探针，会影响所有线程；当然，每个线程命中探测点（以及运行回调函数）是相对独立的。多个线程可能同时运行相同的回调函数。如果你想要一个特定的线程或是一组线程运行一个特定的回调函数，那回调函数应该检查 current 或 current-\u0026gt;pid 来确认哪个线程命中了探测点。\n当进程克隆一个新的线程时，该线程自动的共享所有为进程创建的探针。\n要记住，注册或注销探针的时候，要等到 Utrace 停止了进程中的所有线程后，才会插入或删除断点。注册/注销函数在断点已经被插入或移除之后才返回（看下一章节）。\n探针回调函数內注册探针 uprobe 或 uretprobe 回调函数可以调用 Uprobes API 中的任何函数（[un]register_uprobe(), [un]register_uretprobe()）。探针回调函数甚至可以注销它自己。不过，在回调函数中调用的时候，实际的注册/注销操作不会立刻执行。反而，它们会被放入队列，在该探测点已经运行所有回调函数之后执行。在回调函数中，注册/注销函数会返回 -EINPROGRESS。如果在 uprobe 对象中设置了 registration_callback 字段，会在注册/注销操作完成的时候调用。\n已支持的 CPU 架构 uprobes 和 uretprobes 被实现，在下面的架构上：\n i386 x86_64 (AMD-64, EM64T) ppc64 s390x  配置 Uprobes // TODO: 补丁实际上把 Uprobes 配置放在 \u0026ldquo;Instrumentation Support\u0026rdquo; 下面与 Kprobes 一起。需要决定哪个更好。\n在使用 make menuconfig/xconfig/oldconfig 配置内核的时候，确保 CONFIG_UPROBES 设置为 \u0026ldquo;y\u0026rdquo;。在 \u0026ldquo;Process debugging support\u0026rdquo; 下面，选择 \u0026ldquo;Infrastructure for tracing and debugging user processes\u0026rdquo; 开启 Utrace，然后选择 \u0026ldquo;Uprobes\u0026rdquo;。\n确保 \u0026ldquo;Loadable module support\u0026rdquo;（CONFIG_MODULES）和 \u0026ldquo;Module unloading\u0026rdquo; (CONFIG_MODULE_UNLOAD) 都被设置为 \u0026ldquo;y\u0026rdquo;，这样就可以加载或卸载基于 Uprobes 的测试工具模块。\nAPI 参考 Uprobes API 为每种类型的探针分别提供了\u0026quot;注册\u0026quot;和\u0026quot;注销\u0026quot;函数。这有一份这些函数以及相关的探针处理函数的简短说明。例子见文档后半部分。\nregister_uprobe 1 2  #include \u0026lt;linux/uprobes.h\u0026gt;int register_uprobe(struct uprobe *u);   vaddr in the process whose pid is u-pid. When the breakpoint is hit, Uprobes calls u-handler. -- 在 pid 是 u-\u0026gt;pid 的进程中，虚拟地址 u-\u0026gt;vaddr处设置断点。在命中断点的时候，Uprobes 调用 u-\u0026gt;handler。\nregister_uprobe() 调用成功返回 0，如果是在 uprobe 或 uretprobe 回调函数中（因此延迟了）调用返回 -EINPROGRESS，否则返回负的 errno 。\n\u0026ldquo;延迟注册回调\u0026rdquo;，解释了在完成延迟注册后如何通知。\nhandler): -- 用户的回调函数（u-\u0026gt;handler）:\n1 2 3  #include \u0026lt;linux/uprobes.h\u0026gt;#include \u0026lt;linux/ptrace.h\u0026gt;void handler(struct uprobe *u, struct pt_regs *regs);   在断点命中的时候调用，传入指向断点关联的 uprobe 指针 u 和含有保存的寄存器的结构体指针 regs。\nregister_uretprobe 1 2  #include \u0026lt;linux/uprobes.h\u0026gt;int register_uretprobe(struct uretprobe *rp);   u.pid for the function whose address is rp-u.vaddr. When that function returns, Uprobes calls rp-handler. -- 在 pid 是 rp-\u0026gt;u.pid 的进程中，函数地址 rp-\u0026gt;u.vaddr 处创建 return 探针。当该函数返回时，Uprobes 调用 rp-\u0026gt;handler。\nregister_uretprobe() 成功返回 0 ，如果是在 uprobe 或 uretprobe 回调函数中（因此被延迟）调用返回 -EINPROGRESS，否则返回负的 errno。\n\u0026ldquo;延迟注册回调\u0026rdquo;，解释了在完成延迟注册后如何通知。\nhandler): -- 用户的 return 探针回调函数（rp-\u0026gt;handler）：\n1 2 3  #include \u0026lt;linux/uprobes.h\u0026gt;#include \u0026lt;linux/ptrace.h\u0026gt;void uretprobe_handler(struct uretprobe_instance *ri, struct pt_regs *regs);   regs表示用户的 uprobe 处理函数。ri 指向 uretprobe_instance 对象，其关联了当前正在返回的函数实例。可以关注对象中的两个字段：\n ret_addr：return 地址 rp：指向对应的 uretprobe 对象  在 ptrace.h 文件中，regs_return_value(regs) 宏提供了一种简单的抽象，从架构的 ABI 定义的相关寄存器中获得返回值。\nunregister_*probe 1 2 3  #include \u0026lt;linux/uprobes.h\u0026gt;void unregister_uprobe(struct uprobe *u); void unregister_uretprobe(struct uretprobe *rp);   移除探针。注销函数可以在探针注册之后的任何时间调用，还能在 uprobe 或 uretprobe 回调函数中调用。\n延迟注册回调 1 2 3  #include \u0026lt;linux/uprobes.h\u0026gt;void registration_callback(struct uprobe *u, int reg, enum uprobe_type type, int result);   registration_callback for [un]register_uprobe or rp-u.registration_callback for [un]register_uretprobe. Uprobes calls that callback function, if any, passing it the following values: - u = the address of the uprobe object. (For a uretprobe, you can use container_of(u, struct uretprobe, u) to `obtain` the address of the uretprobe object.) - reg = 1 for register_u[ret]probe() or 0 for unregister_u[ret]probe() - type = UPTY_UPROBE or UPTY_URETPROBE - result = the return value that register_u[ret]probe() would have returned if this weren't a delayed operation. This is always 0 for unregister_u[ret]probe(). -- 像前面提到的函数，可以在 uprobe 或 uretprobe 回调函数内部调用。当发生这种情况的时候，注销/注册操作会被延迟，直到与探测点关联的所有回调函数都已运行之后执行。在完成注销/注册操作之后，Uprobes 会检查 uprobe 关联的 registration_callback 成员变量：uprobe 对应 u-\u0026gt;registration_callback 或者 uretprobe 对应 rp-\u0026gt;u.registration_callback。如果存在 Uprobes 会调用 registration_callback 回调函数，并传入下面的值：\n u = uprobe 对象的地址。（uretprobe 对象，可以使用 container_of(u, struct uretprobe, u) 获得 uretprobe 对象的地址。）   reg = 1 for register_u[ret]probe() or 0 for unregister_u[ret]probe() type = UPTY_UPROBE or UPTY_URETPROBE   result = 如果不是延迟操作，作为 register_u[ret]probe() 的返回值。对于 unregister_u[ret]probe() 总是返回 0 。  注意：Uprobes 只在延迟注销/注册的情况下调用 registration_callback。\nUprobes 功能与限制 希望用户给 uprobe 结构体的成员赋值：pid, vaddr, handler, （如果需要）registration_callback。其他保留的成员给 Uprobes 使用。如果做了下面这些事情，Uprobes 可能会产生不期望的结果：\n 把保留的 uprobe 结构体成员设置为非 0 值 在注册期间改变 uprobe 或 uretprobe 对象的内容 注册已注册的 uprobe 或 uretprobe  Uprobes 允许在特定的地址上注册任意数量的探针（uprobes、uretprobe 都可以）。探针回调函数是按照它们注册的顺序调用的。\n任意数量的内核模块可以同时探测一个特定的进程，而特定的模块也可以同时探测任意数量的进程。\nthreads).\n在进程中的所有线程之间的探针是共享的（包括新创建的线程）。\n如果被探测进程退出或执行，Uprobes 会自动注销所有与之关联的 uprobes 和 uretprobes 。之后再注销这些探针将会视为无效。\n另外，如果从进程的虚拟内存映射删除探测的内存区域的话（例如：通过 dlclose(3) 或 munmap(2)），目前需要先主动注销探针。\n没有方法在 fork 进程时继承探针，Uprobes 会在新创建的子进程中移除所有探测点。关于这点更多的信息见\u0026quot;与 Utrace 交互\u0026rdquo;。\n至少在某些架构上，Uprobes 不会尝试校验，指定的探针地址是否是一条指令的开始。如果你弄错了，可能造成会混乱。\n为避免干扰交互式调试工具，Uprobes 会拒绝在已存在断点指令的地方插入探测点，除非是 Uprobes 放那里的。有一些架构可能会拒绝在其他类型的指令上插入探针。\n如果在可内联的函数中插入一个探针，Uprobes 并不会尝试给该函数的所有内联实例插入探针。如果没有命中期望的探针，要记住，gcc 可能会自动内联一个函数。\n探针回调函数可以修改目标函数的环境 ——例如：修改数据结构，或修改 pt_regs 结构体的内容（从断点返回之后保存的寄存器）。因此，Uprobes 可以用来，安装补丁或测试时注入错误。当然 Uprobes 没有办法区分错误是故意注入的还是意外发生的。所以不要搞事情。\n因为 return 探针是通过使用蹦床的地址替换 return 地址实现的，那么栈回溯和调用 __builtin_return_address() 产生的是蹦床的地址，而不是uretprobed 函数的实际 return 地址。\n如果函数调用的次数与 return 次数不匹配（例如：如果函数调用 longjmp() 退出），在这种函数上注册 return 探针，可能会产生不期望的结果。\n当在探测点注册第一个探针或者注销最后一个探针的时候，Uprobes 要求 Utrace 去\u0026quot;暂停\u0026quot;目标进程，这样 Uprobes 就可以插入或者移除断点指令。如果进程还没有停止，Utrace 会停止它。如果进程正在运行一个可中断的系统调用，可能会让系统调用提早完成或失败而产生 EINTR 信号。（ptrace 系统调用的 PTRACE_ATTACH 请求有同样的问题。）\n当 Uprobes 在先前的未探测的页面上建立探测点的时候，Linux 会通过 copy-on-write 机制创建了这个页面的新副本。在移除探测点的时候，Uprobes 并不会尝试合并同一个页面的副本。如果探测在大量长时间运行的进程中探测大量的页面，会影响内存可用性。\n与 Kprobes 交互 Uprobes 打算与 Kprobes 进行有效的相互操作（见 Documentation/kprobes.txt 文件）。例如，检测模块可以同时调用 Kprobes API 和 Uprobes API。\nuprobe 或 uretprobe 回调函数可以注册或注销 kprobes、jprobes、kretprobes，以及 uprobes 和 uretprobes。另外，kprobe、jprobe、kretprobe 回调函数一定不能休眠，不然会无法注册或注销这些探针。（欢迎移除这种限制的想法）\n注意，命中 u[ret]probe 的开销是命中 k[ret]probe 的几倍。\n与 Utrace 交互 在\u0026quot;Utrace 的作用\u0026quot;章节中提到，Uprobes 是 Utrace 的客户端。Uprobes 为每个被探测的线程建立了一个 Utrace 引擎，及为 clone/fork, exec, exit, \u0026ldquo;core-dump\u0026rdquo; 信号（其包括断点陷阱）这类事件创建寄存器回调函数。Uprobes 是在进程首次被探测的时候创建引擎，或者在创建线程时通知，反正先到先处理。\n检测模块可以同时使用 Utrace 和 Uprobes APIs（以及 Kprobes）。这么做的时候，请记住下面的事情：\n 对于特定的事件，Utrace 回调函数是按引擎的创建顺序调用的。目前 Utrace 没有机制来改变顺序。 在 Uprobes 得知目标进程创建了子进程后，会在子进程中移除断点。   在 Uprobes 得知目标进程已经执行或退出后，将会清理这个进程中的数据结构（先允许终止未完成的注销、注册操作）。   当目标线程命中断点或被探测指令单步执行完成的时候，通知已设置 UTRACE_EVENT(SIGNAL_CORE) 标记的引擎。Uprobes 信号回调函数防止（通过 UTRACE_ACTION_HIDE）这个事件，报告给在列表后面的引擎。但，如果你的引擎是在 Uprobes 的引擎之前创建的，还是会收到这个事件。  如果你想在新的子进程中创建探针，可以用以下办法：\n 用 Utrace 注册一个 report_clone 回调函数。在这个回调函数中，以 CLONE_THREAD 标记区分创建新线程还是进程。   在你的 report_clone 回调函数中，调用 utrace_attach() 附着到子进程，以及设置引擎的 UTRACE_ACTION_QUIESCE 标记。子进程将会停顿在准备要探测的位置。   在 report_quiesce 回调函数中，注册所需要的探针。（注意，不能对父子进程使用同一个探测对象。如果想要复制探测点，必须创建一个新的 u[ret]probe 对象集合。）  Here are sample overhead figures (in usec) for different architectures.\n探针开销 // TODO: 已经过时。\n// TODO: 根据其他架构的测试整理。\n在 2007 年常见的 CPU 上，处理 uprobe 命中大约需要3微秒的时间。基准测试反复命中相同的探测点，每次触发一个简单的处理程序，每秒报告 30w-35w 次命中，具体取决于架构。通常，return 探针命中比 uprobe 命中多花 50％ 的时间。当在某个函数上设置了 return 探针，会在该函数的入口处添加 uprobe ，本质上不会增加开销。\n下面是些不同架构的样本（纳秒）。\nu = uprobe; r = return probe; ur = uprobe + return probe i386: Intel Pentium M, 1495 MHz, 2957.31 bogomips u = 2.9 usec; r = 4.7 usec; ur = 4.7 usec x86_64: AMD Opteron 246, 1994 MHz, 3971.48 bogomips // TODO ppc64: POWER5 (gr), 1656 MHz (SMT disabled, 1 virtual CPU per physical CPU) // TODO TODO  Systemtap：基于探针的检测工具，提供简化的编程接口。SystemTap 已经支持内核探针。还可以利用 Uprobes 。 支持其他 CPU 架构  Uprobes 团队 下面的成员对 Uprobes 作出了主要的贡献：\n Jim Keniston - jkenisto@us.ibm.com Ananth Mavinakayanahalli - ananth@in.ibm.com Prasanna Panchamukhi - prasanna@in.ibm.com Dave Wilder - dwilder@us.ibm.com  Uprobes 例子 这儿有份内核模块样本，展示 Uprobes 的用法，统计在特定地址的指令执行了多少次，以及可选的（除非 verbose=0）输出每次执行。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59  /* uprobe_example.c */ #include \u0026lt;linux/module.h\u0026gt;#include \u0026lt;linux/kernel.h\u0026gt;#include \u0026lt;linux/init.h\u0026gt;#include \u0026lt;linux/uprobes.h\u0026gt; /* * Usage: insmod uprobe_example.ko pid=\u0026lt;pid\u0026gt; vaddr=\u0026lt;address\u0026gt; [verbose=0] * where \u0026lt;pid\u0026gt; identifies the probed process and \u0026lt;address\u0026gt; is the virtual * address of the probed instruction. */ static int pid = 0; module_param(pid, int, 0); MODULE_PARM_DESC(pid, \u0026#34;pid\u0026#34;); static int verbose = 1; module_param(verbose, int, 0); MODULE_PARM_DESC(verbose, \u0026#34;verbose\u0026#34;); static long vaddr = 0; module_param(vaddr, long, 0); MODULE_PARM_DESC(vaddr, \u0026#34;vaddr\u0026#34;); static int nhits; static struct uprobe usp; static void uprobe_handler(struct uprobe *u, struct pt_regs *regs) { nhits++; if (verbose) printk(KERN_INFO \u0026#34;Hit #%d on probepoint at %#lx\\n\u0026#34;, nhits, u-\u0026gt;vaddr); } int __init init_module(void) { int ret; usp.pid = pid; usp.vaddr = vaddr; usp.handler = uprobe_handler; printk(KERN_INFO \u0026#34;Registering uprobe on pid %d, vaddr %#lx\\n\u0026#34;, usp.pid, usp.vaddr); ret = register_uprobe(\u0026amp;usp); if (ret != 0) { printk(KERN_ERR \u0026#34;register_uprobe() failed, returned %d\\n\u0026#34;, ret); return -1; } return 0; } void __exit cleanup_module(void) { printk(KERN_INFO \u0026#34;Unregistering uprobe on pid %d, vaddr %#lx\\n\u0026#34;, usp.pid, usp.vaddr); printk(KERN_INFO \u0026#34;Probepoint was hit %d times\\n\u0026#34;, nhits); unregister_uprobe(\u0026amp;usp); } MODULE_LICENSE(\u0026#34;GPL\u0026#34;);   你可以用下面的 Makefile 编译内核模块 uprobe_example.ko：\n1 2 3 4 5 6 7 8  obj-m := uprobe_example.o KDIR := /lib/modules/$(shell uname -r)/build PWD := $(shell pwd) default: $(MAKE) -C $(KDIR) SUBDIRS=$(PWD) modules clean: rm -f *.mod.c *.ko *.o .*.cmd rm -rf .tmp_versions   例如，如果你想要运行 myprog ，然后监控 myfunc() 的调用情况，你可以这样做：\n1 2 3 4 5 6 7 8 9 10 11 12 13  $ make\t// Build the uprobe_example module. ... $ nm -p myprog | awk \u0026#39;$3==\u0026#34;myfunc\u0026#34;\u0026#39; 080484a8 T myfunc $ ./myprog \u0026amp; $ ps PID TTY TIME CMD 4367 pts/3 00:00:00 bash 8156 pts/3 00:00:00 myprog 8157 pts/3 00:00:00 ps $ su - ... # insmod uprobe_example.ko pid=8156 vaddr=0x080484a8   每次调用 myfunc() 函数，将会在 /var/log/messages 文件中和终端上，看到这种信息：\u0026ldquo;kernel: Hit #1 on probepoint at 0x80484a8\u0026rdquo;。要关闭探测，就移除模块：\n1  # rmmod uprobe_example   将会在 /var/log/messages 文件中和终端上看见这种信息：\u0026ldquo;Probepoint was hit 5 times\u0026rdquo;。\nUretprobes 例子 这是展示 return 探针用法的内核模块样本，输出函数的返回值。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87  /* uretprobe_example.c */ #include \u0026lt;linux/module.h\u0026gt;#include \u0026lt;linux/kernel.h\u0026gt;#include \u0026lt;linux/init.h\u0026gt;#include \u0026lt;linux/uprobes.h\u0026gt;#include \u0026lt;linux/ptrace.h\u0026gt; /* * Usage: * insmod uretprobe_example.ko pid=\u0026lt;pid\u0026gt; func=\u0026lt;addr\u0026gt; [verbose=0] * where \u0026lt;pid\u0026gt; identifies the probed process, and \u0026lt;addr\u0026gt; is the virtual * address of the probed function. */ static int pid = 0; module_param(pid, int, 0); MODULE_PARM_DESC(pid, \u0026#34;pid\u0026#34;); static int verbose = 1; module_param(verbose, int, 0); MODULE_PARM_DESC(verbose, \u0026#34;verbose\u0026#34;); static long func = 0; module_param(func, long, 0); MODULE_PARM_DESC(func, \u0026#34;func\u0026#34;); static int ncall, nret; static struct uprobe usp; static struct uretprobe rp; static void uprobe_handler(struct uprobe *u, struct pt_regs *regs) { ncall++; if (verbose) printk(KERN_INFO \u0026#34;Function at %#lx called\\n\u0026#34;, u-\u0026gt;vaddr); } static void uretprobe_handler(struct uretprobe_instance *ri, struct pt_regs *regs) { nret++; if (verbose) printk(KERN_INFO \u0026#34;Function at %#lx returns %#lx\\n\u0026#34;, ri-\u0026gt;rp-\u0026gt;u.vaddr, regs_return_value(regs)); } int __init init_module(void) { int ret; /* Register the entry probe. */ usp.pid = pid; usp.vaddr = func; usp.handler = uprobe_handler; printk(KERN_INFO \u0026#34;Registering uprobe on pid %d, vaddr %#lx\\n\u0026#34;, usp.pid, usp.vaddr); ret = register_uprobe(\u0026amp;usp); if (ret != 0) { printk(KERN_ERR \u0026#34;register_uprobe() failed, returned %d\\n\u0026#34;, ret); return -1; } /* Register the return probe. */ rp.u.pid = pid; rp.u.vaddr = func; rp.handler = uretprobe_handler; printk(KERN_INFO \u0026#34;Registering return probe on pid %d, vaddr %#lx\\n\u0026#34;, rp.u.pid, rp.u.vaddr); ret = register_uretprobe(\u0026amp;rp); if (ret != 0) { printk(KERN_ERR \u0026#34;register_uretprobe() failed, returned %d\\n\u0026#34;, ret); unregister_uprobe(\u0026amp;usp); return -1; } return 0; } void __exit cleanup_module(void) { printk(KERN_INFO \u0026#34;Unregistering probes on pid %d, vaddr %#lx\\n\u0026#34;, usp.pid, usp.vaddr); printk(KERN_INFO \u0026#34;%d calls, %d returns\\n\u0026#34;, ncall, nret); unregister_uprobe(\u0026amp;usp); unregister_uretprobe(\u0026amp;rp); } MODULE_LICENSE(\u0026#34;GPL\u0026#34;);   像在上面的 uprobe 例子那样编译内核模块。\n1 2 3 4 5 6 7 8 9 10 11  $ nm -p myprog | awk ‘$3==\u0026#34;myfunc\u0026#34;’ 080484a8 T myfunc $ ./myprog \u0026amp; $ ps PID TTY TIME CMD 4367 pts/3 00:00:00 bash 9156 pts/3 00:00:00 myprog 9157 pts/3 00:00:00 ps $ su - … # insmod uretprobe_example.ko pid=9156 func=0x080484a8   在 /var/log/messages 文件中和终端上，会看到如下信息：\n1 2  kernel: Function at 0x80484a8 called kernel: Function at 0x80484a8 returns 0x3   移除模块关闭探测：\n1  # rmmod uretprobe_example   在 /var/log/messages 文件中和终端上，会看到信息：\u0026ldquo;73 calls, 73 returns\u0026rdquo;。\n","description":"","id":0,"section":"posts","tags":["kprobe"],"title":"译｜2008｜User-Space Probes (Uprobes)","uri":"https://jayce.github.io/public/posts/kprobes/user-space-probes/"},{"content":"译者序 这篇文章翻译自 Linux 内核源码树中的 kprobes.txt 文件，此文件描述了 Kprobes 的概念、工作原理、限制等内容。因为文件的最后一次提交是在 2019 年，所以文章标题中的年份也就是指这个意思的。\n下面的表格是对关键词的一点解释，概念其实就这几个。\n   关键词 解释     Kprobes 指的是内核的探测机制、框架，依赖于硬件的特定功能实现的，比如 int3 指令   kprobe 指的是 Kprobes 的对象或结构体，关联探测点和探针   probepoint 探测点，一个可用于观察、监视目的的具体位置，比如：一个函数的入口、返回地址   probe 探针，在探测点做具体事情的对象，比如：分析、追踪    如果用一句话解释 Kprobes 原理就是：Kprobes 在探测点上注册了一些探针，当 CPU 执行到探测点的时候 Kprobes 会调用所有相关探针的回调函数。CPU 是怎么从执行流转到 Kprobes 的呢？\n注：因为水平有限，文中难免存在遗漏或者错误的地方。如有疑问，建议直接阅读原文。\n概念： Kprobes 和 Return Probes Kprobes 能够让你动态的介入内核的任意函数，且无中断的收集调试和性能信息。基本上，你可以捕获内核的任意地址1，指定一个在断点命中候调用回调函数。\n目前，探针有两种类型：kprobes ，kretprobes（也被称为 return 探针）。基本上， kprobe 可以安插到任意指令上。当一个指定的函数返回时触发 return 探针。\n通常，基于 Kprobes 的探测工具被打包成了一个内核模块。模块的初始化函数会安装（注册）一个或多个探针，而模块的卸载函数会注销它们。 register_kprobe() 注册函数指明探针要插入到什么位置，探针命中的时候要调用什么样的函数。\n也有一些用来批量注销或注册一组探针的 register_/unregister_*probes() 函数。在必须一次性注销大量探针的时候，这些函数可以加快注销过程。\n接下来的四个小节会解释不同类型的探针及跳转优化是如何工作的。这些内容讲了一些必须要知道的事项，以便充分利用 Kprobes ，例如： pre_handler 与 post_handler 之间的区别，以及如何使用 kretprobes 的 maxactive 、 nmissed 字段。不过，假如你想马上试试 Kprobes 的话，可以直接跳至[##支持的架构]章节。\nKprobe 如何工作？ Kprobes 在注册了一个 kprobe 后，复制被探测的指令，并且把被探测指令的第一个字节替换为断点指令（例如：在 i386、x86_64 平台上的 int3）。\n在 CPU 命中断点指令时，会发生一个 trap，CPU 的寄存器会被保存，而控制通过 notifier_call_chain 机制转移到 Kprobes 。Kprobes 执行与 kprobe 关联的 pre_handler，并且向它传递 kprobe 结构体和保存的寄存器地址。\n接着，Kprobes 单步执行被探测指令的副本。（虽然单步执行原始指令会更简单，但过后 Kprobes 还必须移除断点指令。当另一个 CPU 执行过探测点的时候，将会打开一个小的时间窗口。）\n在指令单步执行完之后，Kprobes 会执行与 kprobe 关联的 post_handler，如果有的话。然后，继续执行探测点之后的指令。\n改变执行路径 kprobes 能够探测一段正在运行的内核代码，因此它能改变寄存器，包括指令指针。类似保存栈帧、恢复执行路径，这类操作需要非常地小心，因为 kprobes 作用在正在运行的内核上面，需要深入的了解计算结构体系和并行计算才行。\n假如你在 pre_handler 回调函数内改变指令指针（以及设置其它相关的寄存器），那你必须返回非零值，好让 kprobes 停止单步执行并立即返回到指定地址。这也表示 post_handler 不应该再被调用。\n注意，在那些使用 TOC （目录）进行函数调用的架构上，这种操作可能会更困难，因为你必须在你的模块中为你的函数设置新的 TOC，并且在函数返回之后还要恢复先前的 TOC。\nReturn 探针 Return 探针如何工作的？ 在你调用 register_kretprobe() 函数的时候， Kprobes 会在函数的入口处建立一个 kprobe。在调用被探测函数的时候命中这个探针， Kprobes 会保存 return 地址的一个副本，且用一个 “trampoline”（蹦床）的地址替换 return 地址。trampoline 是一段任意的代码 — 通常只是 nop 指令。在启动的时候， Kprobes 在蹦床注册了一个 kprobe。\n在被探测的函数执行 return 指令时，控制转移到蹦床命中探针。 Kprobes 的蹦床处理函数调用与 kretprobe 关联的用户指定的回调函数，然后把保存的指令指针设置为保存的 return 地址，一旦从 trap 返回，执行会在这里恢复。\n在被探测的函数执行期间，它的返回地址被保存在一个 kretprobe_instance 类型的对象中。在调用 register_kretprobe() 函数前，用户设置 kretprobe 结构体的 maxactive 字段表示可同时探测指定函数的实例数量。 register_kretprobe() 函数会预先分配规定数量的 kretprobe_instance 对象。\n例如，假设该函数是非递归的，且在自旋锁锁住的情况下被调用，那 maxactive 的值为 1 应该足够。如果函数是非递归的，且永远不放弃 CPU （例如：通过信号量或抢占），那 NR_CPUS 应该足够。要是 maxactive 的值小于等于零的话，会设置成默认值。如果开启 CONFIG_PREEMPT 选项，默认值为 max(10, 2*NR_CPUS)（在两倍的 CPU 数量与 10 之间取较大的值）。其他情况，默认值为 NR_CPUS（CPU 数量）。\n如果你把 maxactive 设置的很小的话，也不会有什么问题，只是会漏掉一些探针而已。在 kretprobe 结构体中，return 探针注册后 nmissed 字段会设置为 0，之后在每次进入被探测函数且没有可用的 kretprobe_instance 对象关联 return 探测的时候累加。\nKretprobe 入口回调函数 Kretprobes 还提供一个可选的用户回调函数，它运行于函数入口。这个回调函数通过 kretprobe 结构体 entry_handler 字段指定。每当命中放置在函数入口处的 kprobe 时，就会调用用户自定义的 entry_handler 函数。如果 entry_handler 函数返回零（成功），那么对应的 return 回调函数保证会在函数返回的时候被调用。如果 entry_handler 返回一个非零错误， Kprobes 会保留返回地址，而 kretprobe 对特定的函数实例没有影响。\n使用与它们关联的唯一对象 kretprobe_instance，可以匹配许多的 entry 和 return 回调函数调用。另外，用户也可以把每个 return-instace 的私有数据指定为每个 kretprobe_instance 对象的一部分。这在 entry 和 return 回调函数之间共享私有数据时尤其有用。每个私有数据对象的大小可以在 kretprobe 注册时通过 kretprobe 结构体中的 data_size 字段指定。私有数据可以通过每个 kretprobe_instance 对象的 data 字段访问。\n如果已经进入被探测函数但没有可用的 kretprobe_instance 对象，那么除了增加 nmissed 的计数之外，还会跳过 entry_handler 调用。\n跳转优化如何工作的？ 如果内核使用 CONFIG_OPTPROBES=y （x86/x86-64、非抢占式内核上该标记自动地设置为 y）编译，且内核参数 “debug.kprobes_optimization” 设置为 1 （见 sysctl(8) ），那么 Kprobes 尝试在每个探测点用 jump 指令代替 breakpoint 指令来减少命中探针的开销。\n初始化 Kprobe 在注册了一个探针试图优化之前，Kprobes 会在指定的地址插入一个普通的，基于断点的 kprobe。所以，即便不能优化这个特定的探测点，也会有一个探针在那儿。\n安全检查 在进行优化探针之前，Kprobes 会做以下安全检查：\n  Kprobes 校验会被 jump 指令替换的区域（”已优化的区域“）完全处于一个函数内部。（jump 指令是多字节指令，因此可能会覆盖多个指令）\n  Kprobes 分析整个函数，并且确认不会跳入已优化的区域。特别是：\n 该函数不包含间接跳转 该函数不包含引起异常的指令（因为被异常触发的固定代码可能会跳回到已优化的区域 — Kprobes 会检查异常表来验证这一点） 该函数附近没有跳转到已优化的区域（除了第一个字节）    对于已优化区域中的每一个指令，Kprobes 会验证它们能否离线执行。\n  准备 detour 缓冲区  detour 意思是像交通节点（环岛）那样\n 接着，Kprobes 准备一个“环形”缓冲区，包含以下指令序列：\n 推进 CPU 寄存器的代码（模拟断点 trap） 调用蹦床代码，再间接调用用户的探针回调函数 恢复寄存器的代码 优化区域的指令 跳回原始执行路径的指令  优化前 在准备 detour 缓冲区后， Kprobes 会检查确保不出现以下情况：\n 探针有一个 post_handler 回调函数 在优化区域中的其他指令被探测了 已禁用的探针  在上述任何一种情况下，Kprobes 都不会优化探针。因为这都是临时情况，如果情况有变化，Kprobes 会再次进行优化。\n如果 kprobe 可以被优化，Kprobes 会把 kprobe 列入优化队列中，然后启动工作队列 kprobe-optimizer 去优化它。如果被优化的 probepoint 在优化之前命中， Kprobes 通过把 CPU 的指令指针设置为 detour 缓冲区中被复制的代码，将控制权返回到原始指令路径 — 这样做至少避免了单步执行。\n优化 Kprobe-optimizer 并不会立即插入 jump 指令，相反为了安全它会先调用 synchronize_rcu() 函数，因为在处理优化区域的过程中 CPU 可能会被中断 2。如你所知， synchronize_rcu() 函数可以确保所有活跃的中断在调用 synchronize_rcu() 的时候已经完成，但前提是 CONFIG_PREEMPT=n 的时候。所以，kprobe 的优化版本只支持 CONFIG_PREEMPT=n 的内核 3。\n之后， Kprobe-optimizer 调用 stop_machine() 函数替换优化区域，用一个跳转到 detour 缓冲区指令，使用 text_poke_smp() 函数。\n取消优化 当优化的 kprobe 被其他 kprobe 注销、禁用或阻塞的时候，它将不会被优化。如果这种情况在优化完成之前发生，则只是将 kprobe 从优化队列中移除。如果优化已经完成，会通过调用 text_poke_smp() 函数把 jump 指令替换为原始代码（除了第一个字节中的 int3 断点）。\nip and returning 1. However, when the probe is optimized, that `modification` is ignored. `Thus`, if you want to `tweak` the kernel’s execution path, you need to `suppress` optimization, using one of the following techniques: * Specify an empty function for the kprobe’s post_handler. or * Execute ‘sysctl -w debug.kprobes_optimization=n’ -- geeks 注意：\n跳转优化改变了 kprobe 的 pre_handler 的行为。优化前，pre_handler 通过改变 regs-\u0026gt;ip 的同时返回 1 可以改变内核的执行路径。然而，在 probe 被优化的时候，修改会被忽略。因此，如果你想微调内核的执行路径，需要使用一个方法去抑制优化：\n 给 kprobe 的 post_handler 指定一个空函数 执行 sysctl -w debug.kprobes_optimization=n 命令  黑名单 Kprobes 可以探测除自身以外的大部分内核空间。这表示有一些函数 kprobes 无法探测。探测（trapping）这样的函数会导致递归 trap （比如：双重故障）或者嵌套的 probe 回调函数可能永远不会被调用。如果你想添加一个函数到黑名单中，只需要两个步骤：首先，引入 linux/kprobes.h 文件；其次，使用 NOKPROBE_SYMBOL() 宏指定一个要被列入黑名单的函数。 Kprobes 对照黑名单检查传入的 probe 地址，如果传入的地址在黑名单中会拒绝注册。\n支持的架构 Kprobes 和 Kretprobes 已在下面的这些结构体系上实现：\n i386 (Supports jump optimization)（支持跳转优化） x86_64 (AMD-64, EM64T) (Supports jump optimization)（支持跳转优化） ppc64 ia64 (Does not support probes on instruction slot1.)（在 slot1 指令上不支持 probes） sparc64 (Return probes not yet implemented.)（返回 probes 还没实现） arm ppc mips s390 parisc  配置 Kprobes 在使用 make menuconfig/xconfig/oldconfig 配置内核时，确保 CONFIG_KPROBES  设置为 “y”。在 “General setup” 字符后搜索 “Kprobes”。\n为了可以加载和卸载基于 Kprobes 的探测模块，请确保将“支持模块加载”（CONFIG_MODULES）和“模块卸载”（CONFIG_MODULE_UNLOAD）设置为 “y”。\n还要确保将 CONFIG_KALLSYMS  甚至是 CONFIG_KALLSYMS_ALL 都设置为 “y”，因为 kallsyms_lookup_name() 函数被内核里的 kprobe 地址解析代码使用。\n如果你需要在函数中间插入 probe，也许发现“使用 debug info 编译内核” (CONFIG_DEBUG_INFO) 非常有用，因此可以使用 objdump -d -l vmlinux 命令去查看源码到目标代码的映射关系。\nAPI 参考 Kprobes API 为每种探针类型提供了一个”注册“和“注销”函数。还包括批量注册、注销探针的 register_*probes 和 unregister_*probes 函数。这有些迷你手册以及将会用到的相关的探针回调函数的简短说明。相关例子，可查看在 samples/kprobes/ 子目录内的文件。\nregister_kprobe 1 2  #include \u0026lt;linux/kprobes.h\u0026gt;int register_kprobe(struct kprobe *kp);   addr. When the breakpoint is hit, Kprobes calls kp-pre_handler. After the probed instruction is single-stepped, Kprobe calls kp-post_handler. If a fault occurs during execution of kp-pre_handler or kp-post_handler, or during single-stepping of the probed instruction, Kprobes calls kp-fault_handler. Any or all handlers can be NULL. If kp-flags is set KPROBE_FLAG_DISABLED, that kp will be registered but disabled, so, its handlers aren’t hit until calling enable_kprobe(kp). -- 在 kp-\u0026gt;addr 地址设置一个断点。命中断点时，Kprobes 调用 kp-\u0026gt;pre_handler。在探测的指令单步执行后，Kprobe 调用 kp-\u0026gt;post_handler。如果一个错误发生，在执行 kp-\u0026gt;pre_handler 或 kp-\u0026gt;post_handler 期间，又或者是在单步执行被探测指令期间，Kprobes 会调用 kp-\u0026gt;fault_handler。所有回调函数都可以是 NULL。如果 kp-\u0026gt;flags 设置为 KPROBE_FLAG_DISABLED ，kp 将会被注册且处于禁用状态。所以 kp 的回调函数在调用 enable_kprobe(kp) 之前不会被调用。\n注意：\n  通过引入 symbol_name 字段来构造 kprobe，探测点地址解析将会由内核来处理。可以使用以下内容：\nkp.symbol_name = \u0026quot;symbol_name\u0026quot;;\n（64 位 powepc 错综复杂，例如透明地处理函数描述符）\n  如果在符号中用于安装探测点的偏移量是已知的，请使用 kprobes 结构体的 offset 字段。这个字段用于计算探测点。\n  kprobe 的 symbol_name 或者 addr 字段都被指定，kprobe 注册会失败且返回 EINVAL。\n  使用 CISC 架构（如：i386，x86_64），kprobes 代码不会验证，如果 kprobe.addr 在指令边界。谨慎使用 offset。\n  register_kprobe() 函数成功返回 0，其他情况返回一个负的 errno。\n用户的 pre-handler（kp-\u0026gt;pre_handler）函数原型:\n1 2 3  #include \u0026lt;linux/kprobes.h\u0026gt;#include \u0026lt;linux/ptrace.h\u0026gt;int pre_handler(struct kprobe *p, struct pt_regs *regs);   用指向与断点关联的 kprobe 指针 p 以及命中断点时保存的寄存器指针 regs 调用。\npost_handler): -- 用户的 post-handler （kp-\u0026gt;post_handler）函数原型：\n1 2 3 4  #include \u0026lt;linux/kprobes.h\u0026gt;#include \u0026lt;linux/ptrace.h\u0026gt;void post_handler(struct kprobe *p, struct pt_regs *regs, unsigned long flags);   p 和 regs 同 pre_handler 所述。flags 看起来一直是 0。\nfault_handler): -- 用户的 fault-handler （kp-\u0026gt;fault_handler）函数原型：\n1 2 3  #include \u0026lt;linux/kprobes.h\u0026gt;#include \u0026lt;linux/ptrace.h\u0026gt;int fault_handler(struct kprobe *p, struct pt_regs *regs, int trapnr);   p 和 regs 同 pre_handler 所述 。 trapnr 是故障相关的特定架构下的 trap 号（例如：在 i386 上， 13 为普通防护故障，14 为页面故障）。如果成功的处理了异常返回 1。\nregister_kretprobe 1 2  #include \u0026lt;linux/kprobes.h\u0026gt;int register_kretprobe(struct kretprobe *rp);   kp.addr. When that function returns, Kprobes calls rp-handler. You must set rp-maxactive `appropriately` before you call register_kretprobe(); see “How Does a Return Probe Work?” for details. register_kretprobe() returns 0 on success, or a negative errno otherwise. -- 为 rp-\u0026gt;kp.addr 地址的函数建立一个 return 探针。在函数返回时，kprobes 调用 rp-\u0026gt;handler 。在调用 register_kretprobe() 之前必须设置合适的 rp-\u0026gt;maxactive，细节参考 “Return Probe 如何工作？” 。\nregister_kretprobe() 成功返回 0，其他情况返回一个负的 errno。\nhandler): -- 用户的 return 探针回调函数（rp-\u0026gt;handler）原型：\n1 2 3 4  #include \u0026lt;linux/kprobes.h\u0026gt;#include \u0026lt;linux/ptrace.h\u0026gt;int kretprobe_handler(struct kretprobe_instance *ri, struct pt_regs *regs);   regs 同 kprobe.pre_handler 描述那样。ri 指向 kretprobe_instance 对象，其中可能涉及以下字段：\n ret_addr：返回地址 rp：指向相关的 kretprobe 对象 task：指向相关的 task 结构体 data：指向每个 return-instace 私有数据，细节参考 “kretprobe entry-handler”。  regs_return_value(regs) 宏提供一个简单的抽象方法，从架构的 ABI 定义的合适的寄存器中提取返回值。\n目前，回调函数的返回值是被忽略的。\nunregister_*probe 1 2 3  #include \u0026lt;linux/kprobes.h\u0026gt;\tvoid unregister_kprobe(struct kprobe *kp); void unregister_kretprobe(struct kretprobe *rp);   移除探针。注销函数可以在探针被注册后调用。\n注意：\n如果这些发现一个不正确的探针（不包括未注册的探针），它们会清除探针的 addr 字段。\nregister_*probes 1 2 3  #include \u0026lt;linux/kprobes.h\u0026gt;int register_kprobes(struct kprobe **kps, int num); int register_kretprobes(struct kretprobe **rps, int num);   注册数组中 num 个探针。如果在注册期间发生错误，在 register_*probes 函数返回之前会安全地注销数组中已注册的探针，直到发生错误的探针为止。\n kps/rps：指向 *probe 数据结构的指针数组 num：数组的大小  注意：\n必须分配（或定义）指针数组，且在使用这些函数之前设置数组的所有元素。\nunregister_*probes 1 2 3  #include \u0026lt;linux/kprobes.h\u0026gt;void unregister_kprobes(struct kprobe **kps, int num); void unregister_kretprobes(struct kretprobe **rps, int num);   一次性移除指定数组中 num 个探针。\n注意：\n如果这些函数在数组中发现一些不正确的探针（比如：未注册的探针），会清除那些不正确探针的 addr 字段。数组中其他的探针会被注销掉。\ndisable_*probe 1 2 3  #include \u0026lt;linux/kprobes.h\u0026gt;int disable_kprobe(struct kprobe *kp); int disable_kretprobe(struct kretprobe *rp);   临时地禁用某个探针。调用 enable_*probe() 函数可再次启用。必须是已经注册的探针。\nenable_*probe 1 2 3  #include \u0026lt;linux/kprobes.h\u0026gt;int enable_kprobe(struct kprobe *kp); int enable_kretprobe(struct kretprobe *rp);   Enables *probe which has been disabled by disable_*probe(). You must specify the probe which has been registered.\n通过 disable_*probe() 启用已经被禁用的 *probe。必须指定已经注册的 probe。\nKprobes 特性与限制 kprobes 允许在同一个地址插入多个探针。此外，带有 post_handler 的探测点无法被优化。所以，如果在已优化的探测点插入带有 post_handler 回调函数的 kprobe 探针，探测点会自动地变成未优化的。\n通常，可以在内核的任意位置插入探针。特别的是，它可以探测中断处理函数。本节讨论了已知的异常。\n如果试图在实现 Kprobes 的代码中插入一个探针，register_*probe 函数将返回 -EINVAL。（在 kernel/kprobes.c 和 arch/*/kernel/kprobes.c 文件中，还有像 do_page_fault 和 notifier_call_chain 这类的函数）。\n如果在可内联的函数中插入探针，Kprobes 并不会给所有内联实例插入探针。如果没有命中期望的探针，记住一点， gcc 可能会自动内联一个函数。\n探针回调函数可以修改被检测函数的环境 \u0026ndash; 例如，改变内核数据结构或者 pt_regs 数据结构的内容（从断点返回时恢复到寄存器中）。因此，Kprobes 可用于安装 bug 修复或测试时注入错误。当然， Kprobes 是没有办法把故意地注入的错误与意外的错误区分开。不要喝大了搞事情。\nKprobes 不会阻止探针回调函数之间的相互作用 \u0026ndash; 比如，先给 printk() 函数插入探针，接着又从另一个探针回调函数中调用 printk() 函数。如果探针回调函数命中一个探针，那么这第二个探针的回调函数不会执行，将只会累加探针的 kprobe.nmissed 值。\n自 Linux v2.6.15-rc1 开始，多个回调函数（或者相同回调函数的多个实例）可以同时在不同的 CPU 上运行。\n除了注册和注销探针之外，Kprobes 不会用互斥锁或分配内存。\n探针回调函数在禁用抢占或者禁用中断的情况下运行，这取决于架构以及优化状态（例如，kretprobe 和优化的 kprobe 回调函数在 x86/x86-64 上运行时没有禁用中断）。不管如何，你的回调函数都不应该让出 CPU （比如，试图获取信号量或等待 I/O）。\n因为 return 探针是通过把蹦床的地址替换为返回地址来实现的，所以堆栈回溯以及调用 __builtin_return_address() 函数得到的是蹦床的地址，而不是 kretprobed 函数实际 return 地址（就目前我们知道的而言，__builtin_return_address() 函数只用于测试工具和报告错误）。\n如果一个函数的调用次数不能匹配返回的次数，在那个函数上注册的探针可能产生不想要的结果。这种情况，会输出一行 kretprobe BUG!: Processing kretprobe d000000000041aa8 @ c00000000004f48c。有了这行信息，就可以关联导致问题的 kretprobe 实例。涵盖了 do_exit() 函数的情况。 do_execve() 和 do_fork() 函数都不是问题。我们不知道的其他特定的情况，可能会出现问题。\n如果在进入或者退出某个函数时，CPU 在除当前 task 以外的堆栈上运行，那在这个函数上注册 return 探针可能会产生不想要的结果。因为这个原因，Kprobes 不支持 __switch_to() 函数 x86_64 版本的 return 探针（或 kprobes），注册函数会返回 -EINVAL 。\n在 x86/x86-64 架构上，由于 Kprobes 跳转优化修改指令普遍存在，会对优化有一些限制。为解释这一点，我们引入些术语。想象一下，一个由 2 字节指令和 3 字节指令组成的 3 个指令序列。\n1 2 3 4 5 6  IA | [-2][-1][0][1][2][3][4][5][6][7] [ins1][ins2][ ins3 ] [\u0026lt;- DCR -\u0026gt;] [\u0026lt;- JTPR -\u0026gt;]   1 2 3 4 5 6  ins1: 1st Instruction ins2: 2nd Instruction ins3: 3rd Instruction IA: Insertion Address JTPR: Jump Target Prohibition Region DCR: Detoured Code Region   DCR 内的指令被复制到 kprobe 的离线缓冲区中，因为 DCR 内的字节被 5 字节 jump 指令替代了。所以，这儿会有几个限制。\n DCR 内的指令一定是可重定位的 DCR 内的指令一定不能包含 call 指令 JTPR 不能作为 jump 或 call 指令的目标 DCR 不能跨越函数之间的边界  不过，这些限制由内核的指令解码器检查，所以不需要关心这些限制。\n探针的开销 在 2005 年常见的 CPU 上，处理命中 kprobe 要花费 0.5 - 1.0 微秒。具体一点，基准测试反复命中同一个探测点，每一次触发简单的回调函数，每秒 1-2 百万次命中，具体数值取决于 CPU 架构。通常，命中 return 探针比命中 kprobe 多花费 50-75% 的时间。当你把一个 kretprobe 插入到一个函数的时候，实际是在函数入口处添加一个 kprobe，基本上上函数不会增加开销。\n下面有些不同架构开销的样本（微秒）：\nk = kprobe; r = return probe; kr = kprobe + return probe on same function i386: Intel Pentium M, 1495 MHz, 2957.31 bogomips k = 0.57 usec; r = 0.92; kr = 0.99 x86_64: AMD Opteron 246, 1994 MHz, 3971.48 bogomips k = 0.49 usec; r = 0.80; kr = 0.82 ppc64: POWER5 (gr), 1656 MHz (SMT disabled, 1 virtual CPU per physical CPU) k = 0.77 usec; r = 1.26; kr = 1.45  已优化探针开销 通常，命中已优化的 kprobe 要花费 0.07 - 0.1 微妙来处理。这是 x86 架构开销的样本（微妙）：\nk = unoptimized kprobe, b = boosted (single-step skipped), o = optimized kprobe, r = unoptimized kretprobe, rb = boosted kretprobe, ro = optimized kretprobe. i386: Intel(R) Xeon(R) E5410, 2.33GHz, 4656.90 bogomips k = 0.80 usec; b = 0.33; o = 0.05; r = 1.10; rb = 0.61; ro = 0.33 x86-64: Intel(R) Xeon(R) E5410, 2.33GHz, 4656.90 bogomips k = 0.99 usec; b = 0.43; o = 0.06; r = 1.24; rb = 0.68; ro = 0.30  TODO 1. [SystemTap](http://sourceware.org/systemtap)：给基于探针的探测工具提供了一个简单的编程接口。可以试一下 2. sparc64 架构的 kretprobe 3. 支持其他架构 4. 用户空间的探针 5. 观察点探针（在数据引用时触发）  Kprobes 例子 见 samples/kprobes/kprobe_example.c 文件\nKretprobes 例子 见 samples/kprobes/kretprobe_example.c 文件\n有关 Kprobes 的其他信息，请参考以下 URL 链接：\n http://www-106.ibm.com/developerworks/library/l-kprobes.html?ca=dgr-lnxw42Kprobe http://www.redhat.com/magazine/005mar05/features/kprobes/ http://www-users.cs.umn.edu/~boutcher/kprobes/ http://www.linuxsymposium.org/2006/linuxsymposium_procv2.pdf (pages 101-115)  已弃用的机制 现在 Jprobes 是一个不被推荐的机制。依赖它的应该迁移到其他追踪机制或使用旧的内核。请考虑把你的工具迁移到以下工具中：\n 使用 trace-event 追踪带参数的函数   trace-event 是个低开销的静态定义的事件接口（如果关闭，没有明显的开销）。你可以定义新事件，通过 ftrace 或者其他追踪工具追踪它。\n参考以下 URL 链接：\n- https://lwn.net/Articles/379903/\n- https://lwn.net/Articles/381064/\n- https://lwn.net/Articles/383362/\n  使用 ftrace 动态事件（kprobe 事件）和 perf-probe   如果你使用调试信息（CONFIG_DEBUG_INFO=y）编译你的内核，可以用 perf-probe 设置新事件去追踪它，能发现寄存器/栈被分配给了哪个本地变量或者参数。\n参考以下文档：\n- Documentation/trace/kprobetrace.rst\n- Documentation/trace/events.rst\n- tools/perf/Documentation/perf-probe.txt\n 2.6.20) the list of registered kprobes is visible under the /sys/kernel/debug/kprobes/ directory (assuming debugfs is mounted at //sys/kernel/debug). /sys/kernel/debug/kprobes/list: Lists all registered probes on the system: -- kprobes debugfs 接口 最新的内核（\u0026gt; 2.6.20），已经注册的 kprobes 列表位于 /sys/kernel/debug/kprobes/ 目录之下（假设 debugfs 被挂载到 /sys/kernel/debug 目录）。\n/sys/kernel/debug/kprobes/list：列出在系统上所有已注册的 probes：\n1 2  c015d71a k vfs_read+0x0 c03dedc5 r tcp_v4_rcv+0x0   第一列，是已插入探针的内核地址。第二列，是表示探针的类型（k - kprobe，r - kretprobe）。第三列，是指定探针的符号+偏移量（symbol+offset）。如果被探测的函数属于一个模块，那么这个模块的名字也会被列出来。随后的几列显示探针的状态。如果探针在虚拟地址上，并且地址无效（模块初始化部分，模块虚拟地址，对应的模块已经卸载），这类探针会被标记为 [GONE]。如果探针临时被禁用，会被标记为 [DISABLED]。如果探针被优化了，会被标记为 [OPTIMIZED]。如果探针是基于 ftrace 的，会被标记为 [FTRACE]。\n/sys/kernel/debug/kprobes/enabled：强制开启/关闭 kprobes。\n提供一个全局按钮，强制的开启或关闭已注册的 kprobes。默认情况下，所有 kprobes 是开启的。输出 “0” 到这个文件，所有已注册的探针会被卸载，输出 “1” 到这个文件，又重新加载。请注意，这个按钮只是卸载和加载所有 kprobes，并不会改变每个探针的禁用状态。意思是，已经禁用的探针（标记为 [DISABLED]）是不会被激活的。\nkprobes sysctl 接口 /proc/sys/debug/kprobes-optimization： kprobes 优化开关。\n在 CONFIG_OPTPROBES=y 的时候， sysctl 接口提供一个全局按钮，强制的开启或关闭跳转优化（查看跳转章节）。默认情况下，跳转优化是开启的。如果输出 “0” 到这个文件或者通过 sysctl 设置 debug.kprobes_optimization 为 0 ，所有优化的探针将会变成未优化的，而且在这之后任何新的被注册的探针都不会被优化。\n注意，这个按钮会改变优化状态。表示已优化的探针（标记为 [OPTIMIZED]）将变成未优化的（标记 [OPTIMIZED] 会被移除）。如果按钮被打开，探针将再次被优化。\n 有部分内核代码是不能被捕获的，详情见黑名单 \u0026#x21a9;\u0026#xfe0e;\n 请想象第二个指令被中断，然后优化器在中断回调函数正在运行的时候用跳转地址替换它。当中断返回到原始地址时，没有有效指令，这会导致一个意外的结果。 \u0026#x21a9;\u0026#xfe0e;\n 优化安全检查在 ksplice 用于支持 CONFIG_PREEMPT=y 内核上可以用 stop-machine 方法替换。 \u0026#x21a9;\u0026#xfe0e;\n   ","description":"","id":1,"section":"posts","tags":["kprobe"],"title":"译｜2019｜Kernel Probes (Kprobes)","uri":"https://jayce.github.io/public/posts/kprobes/kernel-kprobes/"},{"content":"译者序 本文翻译自 2005 年在 LWN 发布的，一篇 KProbes 入门级的文章：An introduction to KProbes，当时的内核版本为 2.6.11。文中的配图是用 Omnigraffle.app 重新做了一份，顺着作者的思路走一遍。\n注：水平有限，文中难免存在遗漏或者错误的地方。如有疑问，建议直接阅读原文。\n前言 KProbes 作为 Linux 内核的一种调试机制，也可以用来监控生产系统内部的事件。你可以用它来扫除性能瓶颈、记录特定事件、追踪问题等等。 KProbes 是由 IBM 开发出来的，作为另外一种更高级的追踪工具 Dprobes 的一种底层机制。 Dprobes 添加了很多功能，包括它自己的用来编写探针处理函数的脚本语言。不过最终，只有 KProbes 被合并到标准的内核中。\n这篇文章将会描述 2.6.11.7 内核內 KProbes 的实现。 KProbes 非常依赖处理器架构的特殊功能，并且根据执行它的架构会使用略微不同的机制。后续的讨论只与 x86 架构相关。本文假设你对 x86 架构中的中断和异常处理有一定的了解。 目前， KProbes 在 ppc64、x86_64、sparc64、i386 架构上是可用的。\nkernel probe（内核探针）是一组位于某个指令地址上的处理函数。到目前为止，内核中有两种类型的探针，称作 “KProbes” 和 “JProbes”。 KProbe 由 pre-handler 和 post-handler 定义。 当 KProbe 被安装到一个特定的指令上，且指令被执行的时候， pre-handler 会在这之前执行。同样， post-handler 会在这个指令之后执行。 JProbes 用用于在运行时访问内核函数的参数。 JProbe 由 JProbe 处理函数定义，函数原型与要读取的参数的函数相同。当被探测的函数要被执行的时候，控制权会先转移到用户定义的 JProbe 处理函数，之后再将执行权转移到原始函数。 KProbes 软件包是以扩展它自身来构建用于试、追踪、记录的工具而设计的。\n 此图描述了 KProbes 的结构。在 x86 上， KProbes 利用异常处理机制修改了普通的断点、调试和一些其他的异常处理函数，以便达到自己的目的。探针的逻辑大多都是在断点和调试异常函数的上下文中完成的，它们构成了 KProbes 架构依赖层（Architecture Dependent Layer）。 KProbes Manager 是架构无关层（Architecture Independent Layer），它是用来注册和注销探针的。用户在内核模块中准备的探针处理函数通过 KProbes Manager 来注册。\n. The following data structure describes a KProbe. -- KProbes 接口 \u0026lt;linux/kprobes.h\u0026gt; 文件中定义了实现 KProbes 接口的数据结构和函数。以下数据结构描述了一个 KProbe 。\n1 2 3 4 5 6 7 8 9 10  struct kprobe { struct hlist_node hlist; /* Internal */ kprobe_opcode_t addr; /* Address of probe */ kprobe_pre_handler_t pre_handler; /* Address of pre-handler */ kprobe_post_handler_t post_handler; /* Address of post-handler */ kprobe_fault_handler_t fault_handler; /* Address of fault handler */ kprobe_break_handler_t break_handler; /* Internal */ kprobe_opcode_t opcode; /* Internal */ kprobe_opcode_t insn[MAX_INSN_SIZE]; /* Internal */ };   先谈谈注册 KProbe 。用户可通过写一个内核模块把探针插入正在运行的内核内部，内核模块实现了探针的 pre-handler 和 post-handler 函数。如果在执行探针处理函数期间发生故障，用户可通过定义 fault-handler 函数以及传递在 struct kprobe 结构中的地址来处理故障。这些处理函数的原型定义如下。\n1 2 3 4 5  typedef int (*kprobe_pre_handler_t)(struct kprobe*, struct pt_regs*); typedef void (*kprobe_post_handler_t)(struct kprobe*, struct pt_regs*, unsigned long flags); typedef int (*kprobe_fault_handler_t)(struct kprobe*, struct pt_regs*, int trapnr);   可以看到， pre-handler 和 post-handler 都能接受探针的引用以及在探针命中时保存的寄存器。这些值是可以在 pre-handler 或 post-handler 中或需要时使用，还可以在把控制权返回到后续的指令之前修改。也意味着同一个处理函数可用在多个探测位置上。 flags 参数目前还未被使用。 trapnr 参数（用于故障处理函数）包括在处理 KProbe 期间发生的异常编号。要让 KProbe 进一步处理故障，用户定义的故障回调函数可以返回 0。假如故障已经被处理，还想要探针处理函数继续执行可以返回 1。\n请注意，虽然 post-handler 是可选的，但目前探针的 pre-handler 不能为 NULL 。因为在有些情况下可能需要 post-handler，不需要 pre-handler ，所以这点被认为是一个 bug。这种情况，用户还必须定义一个 pre-handler。另外一个 bug （能让内核崩溃）跟在 ret/lret 指令上激活的探针有关。还有一个 bug 与 int3 指令上激活的探针相关。这些的问题都应该在内核的 2.6.12 发行版中被修复了。不管怎样，这些 bugs 可以轻易地避开，而对于那些想要立即使用 KProbes 又没有采用补丁的人而言，不会造成任何严重的问题。\nKProbe 注册函数定义如下：\n1 2  int register_kprobe(struct kprobe *p); int unregister_kprobe(struct kprobe *p);   注册函数接受一个 KProbe 结构体的指针。注意，注册探针的内核模块应该一直保持对这个结构体的引用直到探针被注销。由于对 KProbes 的访问已序列化，探针可以随时注册或者注销探针，探针处理函数内部除外，否则会死锁操作系统。因为，探针处理函数是在得到用来锁定 KProbes 的自旋锁之后执行。注销探针完成之前自旋锁是被锁定的，如果试图在探针处理函数内部注销探针，那将会再一次锁定自旋锁。\n目前，不能在相同的地址上放置多个探针。不过，已经有一个补丁提交到了内核邮件列表，它通过另外一个接口允许在相同的地址上注册多个探针。内核的下一个发布版本中也许会包含它。在此之前，如果已经尝试过的话， register_kprobe() 函数会返回 -EEXIST。\nJProbes 用来在运行时访问一个函数的参数。这是用一个与被探测函数原型相同的 JProbe 处理函数办到的。在运行时，执行原始函数的时候，先复制进程的上下文，再将控制权转移到 JProbe 处理函数。在 JProbe 处理函数返回期间，进程上下文（由寄存器和栈组成）会被恢复，因此在 JProbe 处理函数中对进程上下文所做的任何修改都无效。以先前保存的状态，在放置探针的地方恢复执行。JProbe 由以下结构体表示。\n1 2 3 4  struct jprobe { struct kprobe kp; kprobe_opcode_t *entry; /* user-defined JProbe handler address */ };   用户在 entry 字段设置用来处理探针的函数地址。在 kprobe 结构体中的 addr 字段应该用被访问的函数地址来填充。下面的函数用来注册或注销一个 JProbe：\n1 2  int register_jprobe(struct jprobe *p); void unregister_jprobe(struct jprobe *p);   用户编写的 JProbe 处理函数，应该在要返回的时候调用 jprobe_return() 函数而不是 return 语句。\nKProbes Manager KProbes Manager 负责注册和注销 KProbes 、 JProbes。 kernel/kprobes.c 文件实现 KProbes manager。每个探针是由一个 struct kprobe 结构体来表示的，且保存在一个用探针的目标地址来计算的 hash 表中。用 kprobe_lock 自旋锁来串行化对哈希表的访问。在注册新的探针、注销已存在的探针之前或者命中探针的时候，自旋锁都是被锁定的。这样会阻止在 SMP 机器上并行的执行这些操作。无论什么时候命中探针，探针处理函数都是在禁用中断的情况下调用的。禁用中断，是因为处理探针是个多步骤过程，涉及断点处理以及被探测指令的单步执行。没有简单的方法来保存这些操作之间的状态，因此在处理探针期间中断一直是禁用的。\nManager 是由以下这些函数构成，且附带一点对它们的简短描述。这些函数是架构无关的。同步阅读 kernel/kprobes.c 文件中的代码以及这些内容将会阐明整个实现。\nkp by calling register_kprobe() * void unregister_jprobe(struct jprobe *jp) * Unregisters the struct kprobe used by this JProbe --  void lock_kprobes(void) ：锁定 KProbes 且记录锁定它的 CPU void unlock_kprobes(void) ：解锁 KProbes 且重置已记录的 CPU struct kprobe *get_kprobe(void *addr) ：传入被探测指令的地址，从 hash 表中取回探针 int register_kprobe(struct kprobe *p) ：函数在特定的地址上注册一个探针。注册涉及在探针专用缓冲区中的探针地址处复制指令。在 x86 上，最大的指令大小是 16 个字节，因此这 16 个字节会被复制到特定的地址。然后，用 breakpoint 指令替换位于被探测地址处的指令 void unregister_kprobe(struct kprobe *p) ：注销探针。在指定地址恢复原始指令，且从哈希表中移除探针结构体 int register_jprobe(struct jprobe *jp) ：在一个函数的地址上注册一个 JProbe。 JProbes 使用 KProbes 的机制，在 KProbe 的 pre_handler 处理函数中， JProbes 保存了它自己的函数 setjmp_pre_handler，而且还在 break_handler 函数中保存了 longjmp_break_handler 函数的地址。然后，调用 register_kprobe() 函数注册 kprobe 结构体 jp-\u0026gt;kp void unregister_jprobe(struct jprobe *jp) ：注销 JProbe 使用的 kprobe 结构体  命中 KProbe 的时候发生了什么？  以上涉及处理探针的步骤都是架构相关的，由 arch/i386/kernel/kprobes.c 文件中定义的函数来处理。注册探针后，那些处于激活状态的地址包含了 breakpoint 指令（在 x86 上是 int3）。一旦执行到被探测的地址就会执行 int3 指令，也因此控制权会转到 arch/i386/kernel/traps.c 文件中的 do_int3() 函数。 do_int3() 是通过中断门调用的，所以在控制权转到这里的时候中断是被禁用的。这个函数会通知 KProbes 产生了一个中断， KProbes 会检查中断是不是由 KProbes 的注册函数设置的。如果命中的探测地址上没有探针，只会返回 0。相反，它会调用已注册的探针函数。\n命中 JProbe 的时候发生了什么？  JProbe 必须将控制权转移到另外一个函数，这函数的原型与放置探针的函数相同，然后再将控制权交给原始函数，状态与执行 JProbe 之前相同。JProbe 利用了 KProbe 使用的机制。 JProbe 不是调用用户定义的 pre-handler ，而是指定自己的 pre-handler ，名为 setjmp_pre_handler() ，而且使用了另外一个称为 break_handler 的函数。这过程有三个步骤。\n第一步，在命中断点的时候控制权转到 kprobe_handler() 函数，它会调用 JProbe 的 pre-handler 函数(setjmp_pre_handler())。在把 eip 改成用户定义函数的地址之前，这个函数会把栈和寄存器保存下来。然后，它会返回 1 让 kprobe_handler() 函数直接返回，而不像 KProbe 那样设置单步执行。在返回时，控制权转到用户定义的函数，这样就可以访问原始函数的参数。在用户定义的函数完事后，该调用 jprobe_return() 函数，而不是做普通的 return。\n第二步，jprobe_return() 函数截断当前栈帧并生成一个断点，通过 do_int3() 函数把控制权转移到 kprobe_handler() 函数。 kprobe_handler() 函数发现生成的断点地址（jprobe_handler() 函数中 int3 指令的地址）没有注册探针，但 KProbes 在当前 CPU 上处于活跃状态。它假设断点一定是 JProbes 生成的，因此调用了它先前保存的 current_kprobe break_hanlder 函数。 break_handler 函数会恢复栈以及在控制权转移到用户定义的函数和返回之前保存的寄存器。\n第三步， kprobe_handler() 函数在已设置 JProbe 的指令处设置单步执行，剩下的一系列步骤与 KProbe 相同。\n可能出现的问题 在 KProbes 处理探针的时候，有可能会出现几个问题。第一种，在 SMP 系统上并行处理几个探针。但，所有的探针都共用一个普通的哈希表，那就需要保护它们避免遭到损坏。因此， kprobe_lock 会串行化对探针的处理。\n如果探针被放置在 KProbes 代码内部会发生另外一种问题，导致 KProbes 递归调用探针处理函数。这个问题已经在 kprobe_handler() 函数中处理，它通过检查 KProbes 是否已经在当前 CPU 上运行。这种递归探针会被悄悄的禁掉，并且控制权会返回到先前的探针处理函数。\n如果正在执行 KProbes 的时候发生抢占，在处理探针期间，上下文可以切换到另外一个进程。在先前的探针完全没有处理完的时候，其它的进程可能会触发另一个探针，控制权将再一次转到 kprobe_handler() 函数。当 KProbes 发现新探针正在递归的时候，可能会撤销它。为了避免这个问题，在处理探针的期间抢占是被禁用的。\n同样地，中断被禁用，是因为断点和调试函数是通过中断门调用的，而不是陷阱门。一旦控制权转移到断点或者调试函数就会禁用中断。这些操作是在 arch/i386/kernel/traps.c 文件中做的。\n在处理探针期间可能会发生故障。如果在用户已经定义了一个故障处理函数的情况下，控制权会被转移到故障处理函数。如果用户定义的故障处理函数返回 0 ，那么这个错误由内核来处理。此外， KProbes 会假设故障已经被处理，控制权会回到探针处理函数。\n结论 KProbes 一个极好的调试、追踪工具，也可用来测量性能。开发者可以用它来追踪他们的程序在内核中的路径，以便调试。系统管理员可以用它在生产系统中追踪内核的事件。KProbes 也可以用于非关键性性能测量。不过，目前 KProbes 的实现，在处理探针的过程中引入一些延迟。延迟背后的原因是只有一个 kprobe_lock，它在 SMP 机器上串行化了探针的执行。另外一个因素是 KProbes 使用的机制，它使用多个异常去处理一个探针。异常处理是非常昂贵的操作，会导致延迟。需要在这方面展开工作，提升 SMP 的可扩展性，缩短处探针的处理时间，使得 KProbes 成为可行的性能测量工具。\n但是，KProbes 不能直接用来做这些事情。原始的状态下，用户可编写一个实现探针函数的内核模块。不过，为了更方便的使用它，必须使用更高级的工具。这种高级工具可以包含标准的探针函数，用它们来实现所要的功能，或者它们可以包含一种类似 DProbes 的脚本语言，用来生成 probe-handlers。\n相关链接  KProbes 一篇关于 KProbes 的介绍性文章，以及一些如何使用它的例子（译注：此链接已经失效） DProbes Linux 基于 KProbes 的脚本化追踪工具 Network Packet Tracing Patch 这个补丁能让 Dprobes 追踪网络数据包经过内核栈的路径 KProbes debugfs patch 这个补丁列出所有探针，它们都可以通过 debugfs 应用在任意地址上（译注：此链接已失效） SysRq key for KProbes Patch 这个补丁能够让 SysRq 键列出所有已应用的探针（译注：此链接已失效） SystemTap Linux 内核追踪工具 - 正在开发中  致谢 作者要感谢他的编辑们 Jonathan Corbet, Kalyan T.B. (HP), Siddharth Seth (IIITB) 和 Bharata B. Rao (HP) 审阅这篇文章以及给出了他们的反馈、意见、建议等等，并帮助改进这片文章。\n","description":"","id":2,"section":"posts","tags":["kprobe"],"title":"译｜2005｜ An Introduction to Kprobes","uri":"https://jayce.github.io/public/posts/kprobes/an-introduction-to-kprobes/"}]