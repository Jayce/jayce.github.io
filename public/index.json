[{"content":"译者序 这篇文章翻译自 Linux 内核源码树中的 kprobes.txt 文件，此文件描述了 Kprobes 的概念、工作原理、限制等内容。因为文件的最后一次提交是在 2019 年，所以文章标题中的年份也就是指这个意思的。\n注：因为水平有限，文中难免存在遗漏或者错误的地方。如有疑问，建议直接阅读原文。\n概念： Kprobes 和 Return Probes Kprobes 能够让你动态的介入内核的任意函数，且无中断的收集调试和性能信息。几乎可以调试任意内核代码地址1，指定一个回调函数，在断点命中的时候调用。\n目前，探针有两种类型：kprobes ，kretprobes（也被称为 return 探针）。基本上， kprobe 可以安插到任意指令上。当一个指定的函数返回时触发 return 探针。\n通常，基于 Kprobes 的探测工具被打包成了一个内核模块。模块的初始化函数会安装（注册）一个或多个探针，而模块的卸载函数会注销它们。 register_kprobe() 注册函数指明探针要插入到什么位置，探针命中的时候要调用什么样的函数。\n也有一些用来批量注销或注册一组探针的 register_/unregister_*probes() 函数。在必须一次性注销大量探针的时候，这些函数可以加快注销过程。\n接下来的四个小节会解释不同类型的探针及跳转优化是如何工作的。这些内容讲了一些必须要知道的事项，以便充分利用 Kprobes ，例如： pre_handler 与 post_handler 之间的区别，以及如何使用 kretprobes 的 maxactive 、 nmissed 字段。不过，假如你想马上试试 Kprobes 的话，可以直接跳至[##支持的架构]章节。\nKprobe 如何工作？ Kprobes 在注册了一个 kprobe 后，复制被探测的指令，并且把被探测指令的第一个字节替换为断点指令（例如：在 i386、x86_64 平台上的 int3）。\n在 CPU 命中断点指令时，会发生一个 trap，CPU 的寄存器会被保存，而控制通过 notifier_call_chain 机制转移到 Kprobes 。Kprobes 执行与 kprobe 关联的 pre_handler，并且向它传递 kprobe 结构体和保存的寄存器地址。\n接着，Kprobes 单步执行被探测指令的副本。（虽然单步执行原始指令会更简单，但过后 Kprobes 还必须移除断点指令。当另一个 CPU 执行过探测点的时候，将会打开一个小的时间窗口。）\n在指令单步执行完之后，Kprobes 会执行与 kprobe 关联的 post_handler，如果有的话。然后，继续执行探测点之后的指令。\n改变执行路径 kprobes 能够探测一段正在运行的内核代码，因此它能改变寄存器，包括指令指针。类似保存栈帧、恢复执行路径，这类操作需要非常地小心，因为 kprobes 作用在正在运行的内核上面，需要深入的了解计算结构体系和并行计算才行。\n假如你在 pre_handler 回调函数内改变指令指针（以及设置其它相关的寄存器），那你必须返回非零值，好让 kprobes 停止单步执行并立即返回到指定地址。这也表示 post_handler 不应该再被调用。\n注意，在那些使用 TOC （目录）进行函数调用的架构上，这种操作可能会更困难，因为你必须在你的模块中为你的函数设置新的 TOC，并且在函数返回之后还要恢复先前的 TOC。\n TOC 函数调用机制？\n Return 探针 Return 探针如何工作的？ 在你调用 register_kretprobe() 函数的时候， Kprobes 会在函数的入口处建立一个 kprobe。在调用被探测函数的时候命中这个探针， Kprobes 会保存 return 地址的一个副本，且用一个 “trampoline”（蹦床）的地址替换 return 地址。trampoline 是一段任意的代码 — 通常只是 nop 指令。在启动的时候， Kprobes 在蹦床注册了一个 kprobe。\n在被探测的函数执行 return 指令时，控制转移到蹦床命中探针。 Kprobes 的蹦床处理函数调用与 kretprobe 关联的用户指定的回调函数，然后把保存的指令指针设置为保存的 return 地址，一旦从 trap 返回，执行会在这里恢复。\n在被探测的函数执行期间，它的返回地址被保存在一个 kretprobe_instance 类型的对象中。在调用 register_kretprobe() 函数前，用户设置 kretprobe 结构体的 maxactive 字段表示可同时探测指定函数的实例数量。 register_kretprobe() 函数会预先分配规定数量的 kretprobe_instance 对象。\n例如，假设该函数是非递归的，且在自旋锁锁住的情况下被调用，那 maxactive 的值为 1 应该足够。如果函数是非递归的，且永远不放弃 CPU （例如：通过信号量或抢占），那 NR_CPUS 应该足够。要是 maxactive 的值小于等于零的话，会设置成默认值。如果开启 CONFIG_PREEMPT 选项，默认值为 max(10, 2*NR_CPUS)（在两倍的 CPU 数量与 10 之间取较大的值）。其他情况，默认值为 NR_CPUS（CPU 数量）。\n如果你把 maxactive 设置的很小的话，也不会有什么问题，只是会漏掉一些探针而已。在 kretprobe 结构体中，return 探针注册后 nmissed 字段会设置为 0，之后在每次进入被探测函数且没有可用的 kretprobe_instance 对象关联 return 探测的时候累加。\nKretprobe 入口回调函数 Kretprobes 还提供一个可选的用户回调函数，它运行于函数入口。这个回调函数通过 kretprobe 结构体 entry_handler 字段指定。每当命中放置在函数入口处的 kprobe 时，就会调用用户自定义的 entry_handler 函数。如果 entry_handler 函数返回零（成功），那么对应的 return 回调函数保证会在函数返回的时候被调用。如果 entry_handler 返回一个非零错误， Kprobes 会保留返回地址，而 kretprobe 对特定的函数实例没有影响。\n生词：invocation（名词，调用）, corresponding\n使用与它们关联的唯一对象 kretprobe_instance，可以匹配许多的 entry 和 return 回调函数调用。另外，用户也可以把每个 return-instace 的私有数据指定为每个 kretprobe_instance 对象的一部分。这在 entry 和 return 回调函数之间共享私有数据时尤其有用。每个私有数据对象的大小可以在 kretprobe 注册时通过 kretprobe 结构体中的 data_size 字段指定。私有数据可以通过每个 kretprobe_instance 对象的 data 字段访问。\n如果已经进入被探测函数但没有可用的 kretprobe_instance 对象，那么除了增加 nmissed 的计数之外，还会跳过 entry_handler 调用。\n跳转优化如何工作的？ 如果内核使用 CONFIG_OPTPROBES=y （x86/x86-64、非抢占式内核上该标记自动地设置为 y）编译，且内核参数 “debug.kprobes_optimization” 设置为 1 （见 sysctl(8) ），那么 Kprobes 尝试在每个探测点用 jump 指令代替 breakpoint 指令来减少命中探针的开销。\n初始化 Kprobe 在注册了一个探针试图优化之前，Kprobes 会在指定的地址插入一个普通的，基于断点的 kprobe。所以，即便不能优化这个特定的探测点，也会有一个探针在那儿。\n安全检查 在进行优化探针之前，Kprobes 会做以下安全检查：\n  Kprobes 校验会被 jump 指令替换的区域（”已优化的区域“）完全处于一个函数内部。（jump 指令是多字节指令，因此可能会覆盖多个指令）\n  Kprobes 分析整个函数，并且确认不会跳入已优化的区域。特别是：\n 该函数不包含间接跳转 该函数不包含引起异常的指令（因为被异常触发的固定代码可能会跳回到已优化的区域 — Kprobes 会检查异常表来验证这一点） 该函数附近没有跳转到已优化的区域（除了第一个字节）    对于已优化区域中的每一个指令，Kprobes 会验证它们能否离线执行。\n  准备 detour 缓冲区 接着，Kprobes 准备一个“环形”缓冲区，包含以下指令序列：\n 推进 CPU 寄存器的代码（模拟断点 trap） 调用蹦床代码，再间接调用用户的 probe 回调函数 恢复寄存器的代码 优化区域的指令 跳回原始执行路径的指令  优化前 在准备 detour 缓冲区后， Kprobes 确保以下情况不存在：\n 这个 probe 有一个 post_handler 优化区域中的其他指令被探测 probe 被禁用  在上述任何一种情况下，Kprobes 都不会优化探针。因为这些都是临时情况，如果情况发生变化的话，Kprobes 会再次尝试优化。\n如果 kprobe 可以被优化，Kprobes 会把 kprobe 列入优化队列中，然后启动工作队列 kprobe-optimizer 去优化它。如果被优化的 probepoint 在优化之前命中， Kprobes 通过把 CPU 的指令指针设置为 detour 缓冲区中被复制的代码，将控制权返回到原始指令路径 — 这样做至少避免了单步执行。\n优化 Kprobe-optimizer 并不会立即插入 jump 指令，相反为了安全它会先调用 synchronize_rcu() 函数，因为在处理优化区域的过程中 CPU 可能会被中断 22。如你所知， synchronize_rcu() 函数可以确保所有活跃的中断在调用 synchronize_rcu() 的时候已经完成，但前提是 CONFIG_PREEMPT=n 的时候。所以，kprobe 的优化版本只支持 CONFIG_PREEMPT=n 的内核 33。\n之后， Kprobe-optimizer 调用 stop_machine() 函数替换优化区域，用一个跳转到 detour 缓冲区指令，使用 text_poke_smp() 函数。\n取消优化 当优化的 kprobe 被其他 kprobe 注销、禁用或阻塞的时候，它将不会被优化。如果这种情况在优化完成之前发生，则只是将 kprobe 从优化队列中移除。如果优化已经完成，会通过调用 text_poke_smp() 函数把 jump 指令替换为原始代码（除了第一个字节中的 int3 断点）。\nip and returning 1. However, when the probe is optimized, that `modification` is ignored. `Thus`, if you want to `tweak` the kernel’s execution path, you need to `suppress` optimization, using one of the following techniques: * Specify an empty function for the kprobe’s post_handler. or * Execute ‘sysctl -w debug.kprobes_optimization=n’ -- geeks 注意：\n跳转优化改变了 kprobe 的 pre_handler 的行为。优化前，pre_handler 通过改变 regs-\u0026gt;ip 的同时返回 1 可以改变内核的执行路径。然而，在 probe 被优化的时候，修改会被忽略。因此，如果你想微调内核的执行路径，需要使用一个方法去抑制优化：\n* 给 kprobe 的 post_handler 指定一个空函数 * 执行 `sysctl -w debug.kprobes_optimization=n` 命令  Kprobes 可以探测除自身以外的大部分内核空间。这表示有一些函数 kprobes 无法探测。探测（trapping）这样的函数会导致递归 trap （比如：双重故障）或者嵌套的 probe 回调函数可能永远不会被调用。如果你想添加一个函数到黑名单中，只需要两个步骤：首先，引入 linux/kprobes.h 文件；其次，使用 NOKPROBE_SYMBOL() 宏指定一个要被列入黑名单的函数。 Kprobes 对照黑名单检查传入的 probe 地址，如果传入的地址在黑名单中会拒绝注册。\n支持的架构 Kprobes 和 Kretprobes 已在下面的这些结构体系上实现：\n i386 (Supports jump optimization)（支持跳转优化） x86_64 (AMD-64, EM64T) (Supports jump optimization)（支持跳转优化） ppc64 ia64 (Does not support probes on instruction slot1.)（在 slot1 指令上不支持 probes） sparc64 (Return probes not yet implemented.)（返回 probes 还没实现） arm ppc mips s390 parisc  配置 Kprobes 在使用 make menuconfig/xconfig/oldconfig 配置内核时，确保 CONFIG_KPROBES  设置为 “y”。在 “General setup” 字符后搜索 “Kprobes”。\n为了可以加载和卸载基于 Kprobes 的探测模块，请确保将“支持模块加载”（CONFIG_MODULES）和“模块卸载”（CONFIG_MODULE_UNLOAD）设置为 “y”。\n还要确保将 CONFIG_KALLSYMS  甚至是 CONFIG_KALLSYMS_ALL 都设置为 “y”，因为 kallsyms_lookup_name() 函数被内核里的 kprobe 地址解析代码使用。\n如果你需要在函数中间插入 probe，也许发现“使用 debug info 编译内核” (CONFIG_DEBUG_INFO) 非常有用，因此可以使用 objdump -d -l vmlinux 命令去查看源码到目标代码的映射关系。\nAPI 参考 Kprobes API 为每种探针类型提供了一个”注册“和“注销”函数。还包括批量注册、注销探针的 register_*probes 和 unregister_*probes 函数。这有些迷你手册以及将会用到的相关的探针回调函数的简短说明。相关例子，可查看在 samples/kprobes/ 子目录内的文件。\nregister_kprobe 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 535 536 537 538 539 540 541 542 543 544 545 546 547 548 549 550 551 552 553 554 555 556 557 558 559 560 561 562 563 564 565 566 567 568 569 570 571 572 573  #include \u0026lt;linux/kprobes.h\u0026gt;int register_kprobe(struct kprobe *kp); ```c \u0026lt;!-- Sets a breakpoint at the address kp-\u0026gt;addr. When the breakpoint is hit, Kprobes calls kp-\u0026gt;pre_handler. After the probed instruction is single-stepped, Kprobe calls kp-\u0026gt;post_handler. If a fault occurs during execution of kp-\u0026gt;pre_handler or kp-\u0026gt;post_handler, or during single-stepping of the probed instruction, Kprobes calls kp-\u0026gt;fault_handler. Any or all handlers can be NULL. If kp-\u0026gt;flags is set KPROBE_FLAG_DISABLED, that kp will be registered but disabled, so, its handlers aren’t hit until calling enable_kprobe(kp). --\u0026gt; 在 `kp-\u0026gt;addr` 地址设置一个断点。命中断点时，Kprobes 调用 `kp-\u0026gt;pre_handler`。在探测的指令单步执行后，Kprobe 调用 `kp-\u0026gt;post_handler`。如果一个错误发生，在执行 `kp-\u0026gt;pre_handler` 或 `kp-\u0026gt;post_handler` 期间，又或者是在单步执行被探测指令期间，Kprobes 会调用 `kp-\u0026gt;fault_handler`。所有回调函数都可以是 `NULL`。如果 `kp-\u0026gt;flags` 设置为 `KPROBE_FLAG_DISABLED` ，`kp` 将会被注册且处于禁用状态。所以 `kp` 的回调函数在调用 `enable_kprobe(kp)` 之前不会被调用。 \u0026lt;!-- .. note 1. With the introduction of the “symbol_name” field to struct kprobe, the probepoint address resolution will now be taken care of by the kernel. The following will now work: kp.symbol_name = “symbol_name”; (64-bit powerpc `intricacies` such as function descriptors are handled `transparently`) 2. Use the “offset” field of struct kprobe if the offset into the symbol to install a probepoint is known. This field is used to calculate the probepoint. 3. Specify either the kprobe “symbol_name” OR the “addr”. If both are specified, kprobe registration will fail with -EINVAL. 4. With CISC architectures (such as i386 and x86_64), the kprobes code does not validate if the kprobe.addr is at an instruction `boundary`. Use “offset” with `caution`. register_kprobe() returns 0 on success, or a negative errno otherwise. --\u0026gt; 注意： 1. 通过引入 `symbol_name` 字段来构造 kprobe，探测点地址解析将会由内核来处理。现在可以使用以下内容： `kp.symbol_name = “symbol_name”;` （64 位 powepc 错综复杂，例如透明地处理函数描述符） 2. 如果在符号中用于安装 probepoint 的偏移量是已知的，使用 kprobes 结构体的 `offset` 字段。这个字段用于计算探测点。 3. kprobe 的 `symbol_name` 或者 `addr` 字段都被指定，kprobe 注册会失败且返回 `EINVAL`。 4. 使用 CISC 架构（如：i386，x86_64），kprobes 代码不会验证，如果 `kprobe.addr` 在指令边界。谨慎使用 `offset`。 `register_kprobe()` 函数成功返回 0，其他情况返回一个负的 `errno`。 \u0026lt;!-- User’s pre-handler (kp-\u0026gt;pre_handler): --\u0026gt; 用户的 pre-handler（`kp-\u0026gt;pre_handler`）函数原型: ```c #include \u0026lt;linux/kprobes.h\u0026gt;#include \u0026lt;linux/ptrace.h\u0026gt;int pre_handler(struct kprobe *p, struct pt_regs *regs); ```c \u0026lt;!-- Called with p pointing to the kprobe associated with the breakpoint, and regs pointing to the struct containing the registers saved when the breakpoint was hit. Return 0 here unless you’re a Kprobes geek. --\u0026gt; 用指向与断点关联的 kprobe 指针 `p` 以及命中断点时保存的寄存器指针 `regs` 调用。 \u0026lt;!-- User’s post-handler (kp-\u0026gt;post_handler): --\u0026gt; 用户的 post-handler （`kp-\u0026gt;post_handler`）函数原型： ```c #include \u0026lt;linux/kprobes.h\u0026gt;#include \u0026lt;linux/ptrace.h\u0026gt;void post_handler(struct kprobe *p, struct pt_regs *regs, unsigned long flags); ```c \u0026lt;!-- p and regs are as described for the pre_handler. flags always seems to be zero. --\u0026gt; `p` 和 `regs` 同 `pre_handler` 所述。`flags` 看起来一直是 0。 \u0026lt;!-- User’s fault-handler (kp-\u0026gt;fault_handler): --\u0026gt; 用户的 fault-handler （`kp-\u0026gt;fault_handler`）函数原型： ```c #include \u0026lt;linux/kprobes.h\u0026gt;#include \u0026lt;linux/ptrace.h\u0026gt;int fault_handler(struct kprobe *p, struct pt_regs *regs, int trapnr); ```c \u0026lt;!-- p and regs are as described for the pre_handler. trapnr is the architecture-specific trap number associated with the fault (e.g., on i386, 13 for a general protection fault or 14 for a page fault). Returns 1 if it successfully handled the exception. --\u0026gt; `p` 和 `regs` 同 `pre_handler` 所述 。 `trapnr` 是故障相关的特定架构下的 trap 号（例如：在 i386 上， 13 为普通防护故障，14 为页面故障）。如果成功的处理了异常返回 1。 ## register_kretprobe ```c #include \u0026lt;linux/kprobes.h\u0026gt;int register_kretprobe(struct kretprobe *rp); ```c \u0026lt;!-- Establishes a return probe for the function whose address is rp-\u0026gt;kp.addr. When that function returns, Kprobes calls rp-\u0026gt;handler. You must set rp-\u0026gt;maxactive `appropriately` before you call register_kretprobe(); see “How Does a Return Probe Work?” for details. register_kretprobe() returns 0 on success, or a negative errno otherwise. --\u0026gt; 为 `rp-\u0026gt;kp.addr` 地址的函数建立一个 return 探针。在函数返回时，kprobes 调用 `rp-\u0026gt;handler` 。在调用 `register_kretprobe()` 之前必须设置合适的 `rp-\u0026gt;maxactive`，细节参考 “Return Probe 如何工作？” 。 `register_kretprobe()` 成功返回 0，其他情况返回一个负的 `errno`。 \u0026lt;!-- User’s return-probe handler (rp-\u0026gt;handler): --\u0026gt; 用户的 return 探针回调函数（`rp-\u0026gt;handler`）原型： ```c #include \u0026lt;linux/kprobes.h\u0026gt;#include \u0026lt;linux/ptrace.h\u0026gt;int kretprobe_handler(struct kretprobe_instance *ri, struct pt_regs *regs); ```c \u0026lt;!-- regs is as described for kprobe.pre_handler. ri points to the kretprobe_instance object, of which the following fields may be of interest: * ret_addr: the return address * rp: points to the corresponding kretprobe object * task: points to the corresponding task struct * data: points to per return-instance private data; see “Kretprobe entry-handler” for details. --\u0026gt; `regs` 同 kprobe.pre_handler 描述那样。`ri` 指向 `kretprobe_instance` 对象，其中可能涉及以下字段： * ret_addr：返回地址 * rp：指向相关的 kretprobe 对象 * task：指向相关的 task 结构体 * data：指向每个 return-instace 私有数据，细节参考 “kretprobe entry-handler”。 \u0026lt;!-- The regs_return_value(regs) macro provides a simple abstraction to `extract` the return value from the `appropriate` register as defined by the architecture’s ABI. The handler’s return value is currently ignored. --\u0026gt; `regs_return_value(regs)` 宏提供一个简单的抽象方法，从架构的 ABI 定义的合适的寄存器中提取返回值。 目前，回调函数的返回值是被忽略的。 ## unregister_*probe ```c #include \u0026lt;linux/kprobes.h\u0026gt;\tvoid unregister_kprobe(struct kprobe *kp); void unregister_kretprobe(struct kretprobe *rp); ```c \u0026lt;!-- Removes the specified probe. The unregister function can be called at any time after the probe has been registered. .. note If the functions find an incorrect probe (ex. an unregistered probe), they clear the addr field of the probe. --\u0026gt; 移除探针。注销函数可以在探针被注册后调用。 注意： 如果这些发现一个不正确的探针（不包括未注册的探针），它们会清除探针的 `addr` 字段。 ## register_*probes ```cc #include \u0026lt;linux/kprobes.h\u0026gt;int register_kprobes(struct kprobe **kps, int num); int register_kretprobes(struct kretprobe **rps, int num); ```c \u0026lt;!-- Registers each of the num probes in the specified array. If any error occurs during registration, all probes in the array, up to the bad probe, are safely unregistered before the register_*probes function returns. * kps/rps: an array of pointers to `*probe` data structures * num: the number of the array entries. .. note You have to allocate(or define) an array of pointers and set all of the array entries before using these functions. --\u0026gt; 注册数组中 `num` 个探针。如果在注册期间发生错误，在 `register_*probes` 函数返回之前会安全地注销数组中已注册的探针，直到发生错误的探针为止。 * `kps/rps`：指向 `*probe` 数据结构的指针数组 * `num`：数组的大小 注意： 必须分配（或定义）指针数组，且在使用这些函数之前设置数组的所有元素。 ## unregister_*probes ```c #include \u0026lt;linux/kprobes.h\u0026gt;void unregister_kprobes(struct kprobe **kps, int num); void unregister_kretprobes(struct kretprobe **rps, int num); ```c \u0026lt;!-- Removes each of the num probes in the specified array at once. .. note If the functions find some incorrect probes (ex. unregistered probes) in the specified array, they clear the addr field of those incorrect probes. However, other probes in the array are unregistered correctly. --\u0026gt; 一次性移除指定数组中 `num` 个探针。 注意： 如果这些函数在数组中发现一些不正确的探针（比如：未注册的探针），会清除那些不正确探针的 `addr` 字段。数组中其他的探针会被注销掉。 ## disable_*probe ```c #include \u0026lt;linux/kprobes.h\u0026gt;int disable_kprobe(struct kprobe *kp); int disable_kretprobe(struct kretprobe *rp); ```c \u0026lt;!-- Temporarily disables the specified `*probe`. You can enable it again by using enable_*probe(). You must specify the probe which has been registered. --\u0026gt; 临时地禁用某个探针。调用 `enable_*probe()` 函数可再次启用。必须是已经注册的探针。 ## enable_*probe ```c #include \u0026lt;linux/kprobes.h\u0026gt;int enable_kprobe(struct kprobe *kp); int enable_kretprobe(struct kretprobe *rp); ```c Enables `*probe` which has been disabled by disable_*probe(). You must specify the probe which has been registered. 通过 `disable_*probe()` 启用已经被禁用的 `*probe`。必须指定已经注册的 probe。 \u0026lt;!-- # Kprobes Features and Limitations Kprobes allows multiple probes at the same address. Also, a probepoint for which there is a post_handler cannot be optimized. So if you install a kprobe with a post_handler, at an optimized probepoint, the probepoint will be unoptimized automatically. --\u0026gt; # Kprobes 特性与限制 kprobes 允许在同一个地址插入多个探针。此外，带有 `post_handler` 的探测点无法被优化。所以，如果在已优化的探测点插入带有 `post_handler` 回调函数的 kprobe 探针，探测点会自动地变成未优化的。 \u0026lt;!-- In general, you can install a probe anywhere in the kernel. In particular, you can probe interrupt handlers. Known exceptions are discussed in this section. --\u0026gt; 通常，可以在内核的任意位置插入探针。特别的是，它可以探测中断处理函数。本节讨论了已知的异常。 \u0026lt;!-- The register_*probe functions will return -EINVAL if you attempt to install a probe in the code that implements Kprobes (mostly kernel/kprobes.c and `arch/*/kernel/kprobes.c`, but also functions such as do_page_fault and notifier_call_chain). --\u0026gt; 如果试图在实现 Kprobes 的代码中插入一个探针，`register_*probe` 函数将返回 `-EINVAL`。（在 `kernel/kprobes.c` 和 `arch/*/kernel/kprobes.c` 文件中，还有像 `do_page_fault` 和 `notifier_call_chain` 这类的函数）。 \u0026lt;!-- If you install a probe in an inline-able function, Kprobes makes no attempt to `chase down` all inline instances of the function and install probes there. gcc may inline a function without being asked, so keep this in mind if you’re not seeing the probe hits you expect. --\u0026gt; 如果在可内联的函数中插入探针，Kprobes 并不会给所有内联实例插入探针。如果没有命中期望的探针，记住一点， gcc 可能会自动内联一个函数。 \u0026lt;!-- A probe handler can modify the environment of the probed function -- e.g., by modifying kernel data structures, or by modifying the contents of the pt_regs struct (which are restored to the registers upon return from the breakpoint). So Kprobes can be used, for example, to install a bug fix or to inject faults for testing. Kprobes, of course, has no way to `distinguish` the `deliberately` injected faults from the accidental ones. Don\u0026#39;t drink and probe. --\u0026gt; 探针回调函数可以修改被检测函数的环境 -- 例如，改变内核数据结构或者 `pt_regs` 数据结构的内容（从断点返回时恢复到寄存器中）。因此，Kprobes 可用于安装 bug 修复或测试时注入错误。当然， Kprobes 是没有办法把故意地注入的错误与意外的错误区分开。不要喝大了搞事情。 \u0026lt;!-- Kprobes makes no attempt to prevent probe handlers from stepping on each other — e.g., probing printk() and then calling printk() from a probe handler. If a probe handler hits a probe, that second probe’s handlers won’t be run in that instance, and the kprobe.nmissed member of the second probe will be incremented. --\u0026gt; Kprobes 不会阻止探针回调函数之间的相互作用 -- 比如，先给 `printk()` 函数插入探针，接着又从另一个探针回调函数中调用 `printk()` 函数。如果探针回调函数命中一个探针，那么这第二个探针的回调函数不会执行，将只会累加探针的 `kprobe.nmissed` 值。 \u0026lt;!-- As of Linux v2.6.15-rc1, multiple handlers (or multiple instances of the same handler) may run concurrently on different CPUs. --\u0026gt; 自 Linux v2.6.15-rc1 开始，多个回调函数（或者相同回调函数的多个实例）可以同时在不同的 CPU 上运行。 \u0026lt;!-- Kprobes does not use `mutexes` or allocate memory except during registration and unregistration. --\u0026gt; 除了注册和注销探针之外，Kprobes 不会用互斥锁或分配内存。 \u0026lt;!-- Probe handlers are run with preemption disabled or interrupt disabled, which depends on the architecture and optimization state. (e.g., kretprobe handlers and optimized kprobe handlers run without interrupt disabled on x86/x86-64). In any case, your handler should not yield the CPU (e.g., by attempting to `acquire` a `semaphore`, or waiting I/O). --\u0026gt; 探针回调函数在禁用抢占或者禁用中断的情况下运行，这取决于架构以及优化状态（例如，kretprobe 和优化的 kprobe 回调函数在 x86/x86-64 上运行时没有禁用中断）。不管如何，你的回调函数都不应该让出 CPU （比如，试图获取信号量或等待 I/O）。 \u0026lt;!-- Since a return probe is implemented by replacing the return address with the trampoline\u0026#39;s address, stack `backtraces` and calls to __builtin_return_address() will typically yield the trampoline’s address instead of the real return address for kretprobed functions. (As far as we can tell, __builtin_return_address() is used only for instrumentation and error reporting.) --\u0026gt; 因为 return 探针是通过把蹦床的地址替换为返回地址来实现的，所以堆栈回溯以及调用 `__builtin_return_address()` 函数得到的是蹦床的地址，而不是 kretprobed 函数实际 return 地址（就目前我们知道的而言，`__builtin_return_address()` 函数只用于测试工具和报告错误）。 \u0026lt;!-- If the number of times a function is called does not match the number of times it returns, registering a return probe on that function may produce `undesirable` results. In such a case, a line: kretprobe BUG!: Processing kretprobe d000000000041aa8 @ c00000000004f48c gets printed. With this information, one will be able to `correlate` the exact instance of the kretprobe that caused the problem. We have the do_exit() case covered. do_execve() and do_fork() are not an issue. We’re `unaware of` other specific cases where this could be a problem. --\u0026gt; 如果一个函数的调用次数不能匹配返回的次数，在那个函数上注册的探针可能产生不想要的结果。这种情况，会输出一行 `kretprobe BUG!: Processing kretprobe d000000000041aa8 @ c00000000004f48c`。有了这行信息，就可以关联导致问题的 kretprobe 实例。涵盖了 `do_exit()` 函数的情况。 `do_execve()` 和 `do_fork()` 函数都不是问题。我们不知道的其他特定的情况，可能会出现问题。 \u0026lt;!-- If, upon entry to or exit from a function, the CPU is running on a stack other than that of the current task, registering a return probe on that function may produce undesirable results. For this reason, Kprobes doesn’t support return probes (or kprobes) on the x86_64 version of __switch_to(); the registration functions return -EINVAL. --\u0026gt; 如果在进入或者退出某个函数时，CPU 在除当前 task 以外的堆栈上运行，那在这个函数上注册 return 探针可能会产生不想要的结果。因为这个原因，Kprobes 不支持 `__switch_to()` 函数 x86_64 版本的 return 探针（或 kprobes），注册函数会返回 `-EINVAL` 。 \u0026lt;!-- On x86/x86-64, since the Jump Optimization of Kprobes modifies instructions widely, there are some limitations to optimization. To explain it, we introduce some `terminology`. Imagine a 3-instruction sequence consisting of a two 2-byte instructions and one 3-byte instruction. --\u0026gt; 在 x86/x86-64 架构上，由于 Kprobes 跳转优化修改指令普遍存在，会对优化有一些限制。为解释这一点，我们引入些术语。想象一下，一个由 2 字节指令和 3 字节指令组成的 3 个指令序列。 ```c IA | [-2][-1][0][1][2][3][4][5][6][7] [ins1][ins2][ ins3 ] [\u0026lt;- DCR -\u0026gt;] [\u0026lt;- JTPR -\u0026gt;] ```c ```c ins1: 1st Instruction ins2: 2nd Instruction ins3: 3rd Instruction IA: Insertion Address JTPR: Jump Target Prohibition Region DCR: Detoured Code Region ```c \u0026lt;!-- The instructions in DCR are copied to the out-of-line buffer of the kprobe, because the bytes in DCR are replaced by a 5-byte jump instruction. So there are several limitations. a) The instructions in DCR must be relocatable. b) The instructions in DCR must not include a call instruction. c) JTPR must not be targeted by any jump or call instruction. d) DCR must not `straddle` the border between functions. Anyway, these limitations are checked by the in-kernel instruction decoder, so you don’t need to worry about that. --\u0026gt; DCR 内的指令被复制到 kprobe 的离线缓冲区中，因为 DCR 内的字节被 5 字节 jump 指令替代了。所以，这儿会有几个限制。 * DCR 内的指令一定是可重定位的 * DCR 内的指令一定不能包含 `call` 指令 * JTPR 不能作为 `jump` 或 `call` 指令的目标 * DCR 不能跨越函数之间的边界 不过，这些限制由内核的指令解码器检查，所以不需要关心这些限制。 \u0026lt;!-- # Probe Overhead On a typical CPU in use in 2005, a kprobe hit takes 0.5 to 1.0 microseconds to process. Specifically, a benchmark that hits the same probepoint repeatedly, firing a simple handler each time, reports 1-2 million hits per second, depending on the architecture. A return-probe hit typically takes 50-75% longer than a kprobe hit. When you have a return probe set on a function, adding a kprobe at the entry to that function adds `essentially` no overhead. Here are sample overhead `figures` (in usec) for different architectures: --\u0026gt; # 探针的开销 在 2005 年常见的 CPU 上，处理命中 kprobe 要花费 0.5 - 1.0 微秒。具体一点，基准测试反复命中同一个探测点，每一次触发简单的回调函数，每秒 1-2 百万次命中，具体数值取决于 CPU 架构。通常，命中 return 探针比命中 kprobe 多花费 50-75% 的时间。当你把一个 kretprobe 插入到一个函数的时候，实际是在函数入口处添加一个 kprobe，基本上上函数不会增加开销。 下面有些不同架构开销的样本（微秒）： k = kprobe; r = return probe; kr = kprobe + return probe on same function i386: Intel Pentium M, 1495 MHz, 2957.31 bogomips k = 0.57 usec; r = 0.92; kr = 0.99 x86_64: AMD Opteron 246, 1994 MHz, 3971.48 bogomips k = 0.49 usec; r = 0.80; kr = 0.82 ppc64: POWER5 (gr), 1656 MHz (SMT disabled, 1 virtual CPU per physical CPU) k = 0.77 usec; r = 1.26; kr = 1.45 \u0026lt;!-- ## Optimized Probe Overhead Typically, an optimized kprobe hit takes 0.07 to 0.1 microseconds to process. Here are sample overhead figures (in usec) for x86 architectures: --\u0026gt; ## 已优化探针开销 通常，命中已优化的 kprobe 要花费 0.07 - 0.1 微妙来处理。这是 x86 架构开销的样本（微妙）： k = unoptimized kprobe, b = boosted (single-step skipped), o = optimized kprobe, r = unoptimized kretprobe, rb = boosted kretprobe, ro = optimized kretprobe. i386: Intel(R) Xeon(R) E5410, 2.33GHz, 4656.90 bogomips k = 0.80 usec; b = 0.33; o = 0.05; r = 1.10; rb = 0.61; ro = 0.33 x86-64: Intel(R) Xeon(R) E5410, 2.33GHz, 4656.90 bogomips k = 0.99 usec; b = 0.43; o = 0.06; r = 1.24; rb = 0.68; ro = 0.30 # TODO \u0026lt;!-- a. SystemTap (http://sourceware.org/systemtap): Provides a simplified programming interface for probe-based instrumentation. Try it out. b. Kernel return probes for sparc64. c. Support for other architectures. d. User-space probes. e. Watchpoint probes (which fire on data references). --\u0026gt; 1. [SystemTap](http://sourceware.org/systemtap)：给基于探针的探测工具提供了一个简单的编程接口。可以试一下 \t2. sparc64 架构的 kretprobe 3. 支持其他架构 4. 用户空间的探针 5. 观察点探针（在数据引用时触发） # Kprobes 例子 见 [samples/kprobes/kprobe_example.c](https://github.com/torvalds/linux/blob/master/samples/kprobes/kprobe_example.c) 文件  # Kretprobes 例子 见 [samples/kprobes/kretprobe_example.c](https://github.com/torvalds/linux/blob/master/samples/kprobes/kretprobe_example.c) 文件  \u0026lt;!-- For additional information on Kprobes, `refer to` the following URLs: --\u0026gt; 有关 Kprobes 的其他信息，请参考以下 URL 链接： * http://www-106.ibm.com/developerworks/library/l-kprobes.html?ca=dgr-lnxw42Kprobe \t* http://www.redhat.com/magazine/005mar05/features/kprobes/ \t* http://www-users.cs.umn.edu/~boutcher/kprobes/ \t* http://www.linuxsymposium.org/2006/linuxsymposium_procv2.pdf (pages 101-115)  \u0026lt;!-- # Deprecated Features Jprobes is now a `deprecated` feature. People who are depending on it should migrate to other tracing features or use older kernels. Please consider to migrate your tool to one of the following options: * Use trace-event to trace target function with arguments. trace-event is a low-overhead (and almost no visible overhead if it is off) statically defined event interface. You can define new events and trace it via ftrace or any other tracing tools. * Use ftrace dynamic events (kprobe event) with perf-probe. If you build your kernel with debug info (CONFIG_DEBUG_INFO=y), you can find which register/stack is assigned to which local variable or arguments by using perf-probe and set up new event to trace it. --\u0026gt; # 不推荐的特性 现在 Jprobes 是一个不被推荐的机制。依赖它的应该迁移到其他追踪机制或使用旧的内核。请考虑把你的工具迁移到下面这些选项中： * 使用 trace-event 追踪带参数的函数 trace-event 是个低开销的静态定义的事件接口（如果关闭，没有明显的开销）。你可以定义新事件，通过 ftrace 或者其他追踪工具追踪它。 参考以下 URL 链接： - https://lwn.net/Articles/379903/ \t- https://lwn.net/Articles/381064/ \t- https://lwn.net/Articles/383362/  * 使用 ftrace 动态事件（kprobe 事件）和 perf-probe 如果你使用调试信息（`CONFIG_DEBUG_INFO=y`）编译你的内核，可以用 perf-probe 设置新事件去追踪它，能发现寄存器/栈被分配给了哪个本地变量或者参数。 \u0026lt;!-- See following documents: * Documentation/trace/kprobetrace.rst * Documentation/trace/events.rst * tools/perf/Documentation/perf-probe.txt --\u0026gt; 参考以下文档： * [Documentation/trace/kprobetrace.rst](https://github.com/torvalds/linux/blob/master/Documentation/trace/kprobetrace.rst) \t* [Documentation/trace/events.rst](https://github.com/torvalds/linux/blob/master/Documentation/trace/events.rst) \t* [tools/perf/Documentation/perf-probe.txt](https://github.com/torvalds/linux/blob/master/tools/perf/Documentation/perf-probe.txt)  \u0026lt;!-- # The kprobes debugfs interface With recent kernels (\u0026gt; 2.6.20) the list of registered kprobes is visible under the /sys/kernel/debug/kprobes/ directory (assuming debugfs is mounted at //sys/kernel/debug).  /sys/kernel/debug/kprobes/list: Lists all registered probes on the system: --\u0026gt; # kprobes debugfs 接口 最新的内核（\u0026gt; 2.6.20），已经注册的 kprobes 列表位于 `/sys/kernel/debug/kprobes/` 目录之下（假设 debugfs 被挂载到 `/sys/kernel/debug` 目录）。 `/sys/kernel/debug/kprobes/list`：列出在系统上所有已注册的 probes： ```c c015d71a k vfs_read+0x0 c03dedc5 r tcp_v4_rcv+0x0 ```c \u0026lt;!-- The first column provides the kernel address where the probe is inserted. The second column identifies the type of probe (k - kprobe and r - kretprobe) while the third column specifies the symbol+offset of the probe. If the probed function belongs to a module, the module name is also specified. Following columns show probe status. If the probe is on a virtual address that is no longer valid (module init sections, module virtual addresses that correspond to modules that’ve been unloaded), such probes are marked with [GONE]. If the probe is temporarily disabled, such probes are marked with [DISABLED]. If the probe is optimized, it is marked with [OPTIMIZED]. If the probe is ftrace-based, it is marked with [FTRACE]. --\u0026gt; 第一列，是已插入探针的内核地址。第二列，是表示探针的类型（k - kprobe，r - kretprobe）。第三列，是指定探针的符号+偏移量（symbol+offset）。如果被探测的函数属于一个模块，那么这个模块的名字也会被列出来。随后的几列显示探针的状态。如果探针在虚拟地址上，并且地址无效（模块初始化部分，模块虚拟地址，对应的模块已经卸载），这类探针会被标记为 [GONE]。如果探针临时被禁用，会被标记为 [DISABLED]。如果探针被优化了，会被标记为 [OPTIMIZED]。如果探针是基于 ftrace 的，会被标记为 [FTRACE]。 \u0026lt;!-- /sys/kernel/debug/kprobes/enabled: Turn kprobes ON/OFF forcibly. --\u0026gt; `/sys/kernel/debug/kprobes/enabled`：强制开启/关闭 kprobes。 \u0026lt;!-- Provides a knob to globally and forcibly turn registered kprobes ON or OFF. By default, all kprobes are enabled. By echoing “0” to this file, all registered probes will be `disarmed`, till such time a “1” is echoed to this file. Note that this knob just disarms and arms all kprobes and doesn’t change each probe’s disabling state. This means that disabled kprobes (marked [DISABLED]) will be not enabled if you turn ON all kprobes by this knob. --\u0026gt; 提供一个全局按钮，强制的开启或关闭已注册的 kprobes。默认情况下，所有 kprobes 是开启的。输出 “0” 到这个文件，所有已注册的探针会被卸载，输出 “1” 到这个文件，又重新加载。请注意，这个按钮只是卸载和加载所有 kprobes，并不会改变每个探针的禁用状态。意思是，已经禁用的探针（标记为 [DISABLED]）是不会被激活的。 \u0026lt;!-- # The kprobes sysctl interface /proc/sys/debug/kprobes-optimization: Turn kprobes optimization ON/OFF. When CONFIG_OPTPROBES=y, this sysctl interface `appears` and it provides a knob to globally and forcibly turn jump optimization (see section :ref:`kprobes_jump_optimization`) ON or OFF. By default, jump optimization is allowed (ON). If you echo “0” to this file or set “debug.kprobes_optimization” to 0 via sysctl, all optimized probes will be unoptimized, and any new probes registered after that will not be optimized. Note that this knob changes the optimized state. This means that optimized probes (marked [OPTIMIZED]) will be unoptimized ([OPTIMIZED] tag will be removed). If the knob is turned on, they will be optimized again. --\u0026gt; # kprobes sysctl 接口 `/proc/sys/debug/kprobes-optimization`： kprobes 优化开关。 在 `CONFIG_OPTPROBES=y` 的时候， `sysctl` 接口提供一个全局按钮，强制的开启或关闭跳转优化（查看跳转章节）。默认情况下，跳转优化是开启的。如果输出 “0” 到这个文件或者通过 `sysctl` 设置 `debug.kprobes_optimization` 为 0 ，所有优化的探针将会变成未优化的，而且在这之后任何新的被注册的探针都不会被优化。 注意，这个按钮会改变优化状态。表示已优化的探针（标记为 [OPTIMIZED]）将变成未优化的（标记 [OPTIMIZED] 会被移除）。如果按钮被打开，探针将再次被优化。   有部分内核代码是不能被捕获的，详情见 kprobes 黑名单 \u0026#x21a9;\u0026#xfe0e;\n 请想象第二个指令被中断，然后优化器在中断回调函数正在运行的时候用跳转地址替换它。当中断返回到原始地址时，没有有效指令，这会导致一个意外的结果。 \u0026#x21a9;\u0026#xfe0e;\n 优化安全检查在 ksplice 用于支持 CONFIG_PREEMPT=y 内核上可以用 stop-machine 方法替换。 \u0026#x21a9;\u0026#xfe0e;\n   ","description":"","id":0,"section":"posts","tags":["kprobe"],"title":"译｜2019｜Kernel Probes (Kprobes)","uri":"https://jayce.github.io/public/posts/kprobes/kernel-kprobes/"},{"content":"译者序 本文翻译自 2005 年在 LWN 发布的，一篇 KProbes 入门级的文章：An introduction to KProbes，当时的内核版本为 2.6.11。文中的配图是用 Omnigraffle.app 重新做了一份，顺着作者的思路走一遍。\n注：水平有限，文中难免存在遗漏或者错误的地方。如有疑问，建议直接阅读原文。\n前言 KProbes 作为 Linux 内核的一种调试机制，也可以用来监控生产系统内部的事件。你可以用它来扫除性能瓶颈、记录特定事件、追踪问题等等。 KProbes 是由 IBM 开发出来的，作为另外一种更高级的追踪工具 Dprobes 的一种底层机制。 Dprobes 添加了很多功能，包括它自己的用来编写探针处理函数的脚本语言。不过最终，只有 KProbes 被合并到标准的内核中。\n这篇文章将会描述 2.6.11.7 内核內 KProbes 的实现。 KProbes 非常依赖处理器架构的特殊功能，并且根据执行它的架构会使用略微不同的机制。后续的讨论只与 x86 架构相关。本文假设你对 x86 架构中的中断和异常处理有一定的了解。 目前， KProbes 在 ppc64、x86_64、sparc64、i386 架构上是可用的。\nkernel probe（内核探针）是一组位于某个指令地址上的处理函数。到目前为止，内核中有两种类型的探针，称作 “KProbes” 和 “JProbes”。 KProbe 由 pre-handler 和 post-handler 定义。 当 KProbe 被安装到一个特定的指令上，且指令被执行的时候， pre-handler 会在这之前执行。同样， post-handler 会在这个指令之后执行。 JProbes 用用于在运行时访问内核函数的参数。 JProbe 由 JProbe 处理函数定义，函数原型与要读取的参数的函数相同。当被探测的函数要被执行的时候，控制权会先转移到用户定义的 JProbe 处理函数，之后再将执行权转移到原始函数。 KProbes 软件包是以扩展它自身来构建用于试、追踪、记录的工具而设计的。\n 此图描述了 KProbes 的结构。在 x86 上， KProbes 利用异常处理机制修改了普通的断点、调试和一些其他的异常处理函数，以便达到自己的目的。探针的逻辑大多都是在断点和调试异常函数的上下文中完成的，它们构成了 KProbes 架构依赖层（Architecture Dependent Layer）。 KProbes Manager 是架构无关层（Architecture Independent Layer），它是用来注册和注销探针的。用户在内核模块中准备的探针处理函数通过 KProbes Manager 来注册。\n. The following data structure describes a KProbe. -- KProbes 接口 \u0026lt;linux/kprobes.h\u0026gt; 文件中定义了实现 KProbes 接口的数据结构和函数。以下数据结构描述了一个 KProbe 。\n1 2 3 4 5 6 7 8 9 10  struct kprobe { struct hlist_node hlist; /* Internal */ kprobe_opcode_t addr; /* Address of probe */ kprobe_pre_handler_t pre_handler; /* Address of pre-handler */ kprobe_post_handler_t post_handler; /* Address of post-handler */ kprobe_fault_handler_t fault_handler; /* Address of fault handler */ kprobe_break_handler_t break_handler; /* Internal */ kprobe_opcode_t opcode; /* Internal */ kprobe_opcode_t insn[MAX_INSN_SIZE]; /* Internal */ };   先谈谈注册 KProbe 。用户可通过写一个内核模块把探针插入正在运行的内核内部，内核模块实现了探针的 pre-handler 和 post-handler 函数。如果在执行探针处理函数期间发生故障，用户可通过定义 fault-handler 函数以及传递在 struct kprobe 结构中的地址来处理故障。这些处理函数的原型定义如下。\n1 2 3 4 5  typedef int (*kprobe_pre_handler_t)(struct kprobe*, struct pt_regs*); typedef void (*kprobe_post_handler_t)(struct kprobe*, struct pt_regs*, unsigned long flags); typedef int (*kprobe_fault_handler_t)(struct kprobe*, struct pt_regs*, int trapnr);   可以看到， pre-handler 和 post-handler 都能接受探针的引用以及在探针命中时保存的寄存器。这些值是可以在 pre-handler 或 post-handler 中或需要时使用，还可以在把控制权返回到后续的指令之前修改。也意味着同一个处理函数可用在多个探测位置上。 flags 参数目前还未被使用。 trapnr 参数（用于故障处理函数）包括在处理 KProbe 期间发生的异常编号。要让 KProbe 进一步处理故障，用户定义的故障回调函数可以返回 0。假如故障已经被处理，还想要探针处理函数继续执行可以返回 1。\n请注意，虽然 post-handler 是可选的，但目前探针的 pre-handler 不能为 NULL 。因为在有些情况下可能需要 post-handler，不需要 pre-handler ，所以这点被认为是一个 bug。这种情况，用户还必须定义一个 pre-handler。另外一个 bug （能让内核崩溃）跟在 ret/lret 指令上激活的探针有关。还有一个 bug 与 int3 指令上激活的探针相关。这些的问题都应该在内核的 2.6.12 发行版中被修复了。不管怎样，这些 bugs 可以轻易地避开，而对于那些想要立即使用 KProbes 又没有采用补丁的人而言，不会造成任何严重的问题。\nKProbe 注册函数定义如下：\n1 2  int register_kprobe(struct kprobe *p); int unregister_kprobe(struct kprobe *p);   注册函数接受一个 KProbe 结构体的指针。注意，注册探针的内核模块应该一直保持对这个结构体的引用直到探针被注销。由于对 KProbes 的访问已序列化，探针可以随时注册或者注销探针，探针处理函数内部除外，否则会死锁操作系统。因为，探针处理函数是在得到用来锁定 KProbes 的自旋锁之后执行。注销探针完成之前自旋锁是被锁定的，如果试图在探针处理函数内部注销探针，那将会再一次锁定自旋锁。\n目前，不能在相同的地址上放置多个探针。不过，已经有一个补丁提交到了内核邮件列表，它通过另外一个接口允许在相同的地址上注册多个探针。内核的下一个发布版本中也许会包含它。在此之前，如果已经尝试过的话， register_kprobe() 函数会返回 -EEXIST。\nJProbes 用来在运行时访问一个函数的参数。这是用一个与被探测函数原型相同的 JProbe 处理函数办到的。在运行时，执行原始函数的时候，先复制进程的上下文，再将控制权转移到 JProbe 处理函数。在 JProbe 处理函数返回期间，进程上下文（由寄存器和栈组成）会被恢复，因此在 JProbe 处理函数中对进程上下文所做的任何修改都无效。以先前保存的状态，在放置探针的地方恢复执行。JProbe 由以下结构体表示。\n1 2 3 4  struct jprobe { struct kprobe kp; kprobe_opcode_t *entry; /* user-defined JProbe handler address */ };   用户在 entry 字段设置用来处理探针的函数地址。在 kprobe 结构体中的 addr 字段应该用被访问的函数地址来填充。下面的函数用来注册或注销一个 JProbe：\n1 2  int register_jprobe(struct jprobe *p); void unregister_jprobe(struct jprobe *p);   用户编写的 JProbe 处理函数，应该在要返回的时候调用 jprobe_return() 函数而不是 return 语句。\nKProbes Manager KProbes Manager 负责注册和注销 KProbes 、 JProbes。 kernel/kprobes.c 文件实现 KProbes manager。每个探针是由一个 struct kprobe 结构体来表示的，且保存在一个用探针的目标地址来计算的 hash 表中。用 kprobe_lock 自旋锁来串行化对哈希表的访问。在注册新的探针、注销已存在的探针之前或者命中探针的时候，自旋锁都是被锁定的。这样会阻止在 SMP 机器上并行的执行这些操作。无论什么时候命中探针，探针处理函数都是在禁用中断的情况下调用的。禁用中断，是因为处理探针是个多步骤过程，涉及断点处理以及被探测指令的单步执行。没有简单的方法来保存这些操作之间的状态，因此在处理探针期间中断一直是禁用的。\nManager 是由以下这些函数构成，且附带一点对它们的简短描述。这些函数是架构无关的。同步阅读 kernel/kprobes.c 文件中的代码以及这些内容将会阐明整个实现。\nkp by calling register_kprobe() * void unregister_jprobe(struct jprobe *jp) * Unregisters the struct kprobe used by this JProbe --  void lock_kprobes(void) ：锁定 KProbes 且记录锁定它的 CPU void unlock_kprobes(void) ：解锁 KProbes 且重置已记录的 CPU struct kprobe *get_kprobe(void *addr) ：传入被探测指令的地址，从 hash 表中取回探针 int register_kprobe(struct kprobe *p) ：函数在特定的地址上注册一个探针。注册涉及在探针专用缓冲区中的探针地址处复制指令。在 x86 上，最大的指令大小是 16 个字节，因此这 16 个字节会被复制到特定的地址。然后，用 breakpoint 指令替换位于被探测地址处的指令 void unregister_kprobe(struct kprobe *p) ：注销探针。在指定地址恢复原始指令，且从哈希表中移除探针结构体 int register_jprobe(struct jprobe *jp) ：在一个函数的地址上注册一个 JProbe。 JProbes 使用 KProbes 的机制，在 KProbe 的 pre_handler 处理函数中， JProbes 保存了它自己的函数 setjmp_pre_handler，而且还在 break_handler 函数中保存了 longjmp_break_handler 函数的地址。然后，调用 register_kprobe() 函数注册 kprobe 结构体 jp-\u0026gt;kp void unregister_jprobe(struct jprobe *jp) ：注销 JProbe 使用的 kprobe 结构体  命中 KProbe 的时候发生了什么？  以上涉及处理探针的步骤都是架构相关的，由 arch/i386/kernel/kprobes.c 文件中定义的函数来处理。注册探针后，那些处于激活状态的地址包含了 breakpoint 指令（在 x86 上是 int3）。一旦执行到被探测的地址就会执行 int3 指令，也因此控制权会转到 arch/i386/kernel/traps.c 文件中的 do_int3() 函数。 do_int3() 是通过中断门调用的，所以在控制权转到这里的时候中断是被禁用的。这个函数会通知 KProbes 产生了一个中断， KProbes 会检查中断是不是由 KProbes 的注册函数设置的。如果命中的探测地址上没有探针，只会返回 0。相反，它会调用已注册的探针函数。\n命中 JProbe 的时候发生了什么？  JProbe 必须将控制权转移到另外一个函数，这函数的原型与放置探针的函数相同，然后再将控制权交给原始函数，状态与执行 JProbe 之前相同。JProbe 利用了 KProbe 使用的机制。 JProbe 不是调用用户定义的 pre-handler ，而是指定自己的 pre-handler ，名为 setjmp_pre_handler() ，而且使用了另外一个称为 break_handler 的函数。这过程有三个步骤。\n第一步，在命中断点的时候控制权转到 kprobe_handler() 函数，它会调用 JProbe 的 pre-handler 函数(setjmp_pre_handler())。在把 eip 改成用户定义函数的地址之前，这个函数会把栈和寄存器保存下来。然后，它会返回 1 让 kprobe_handler() 函数直接返回，而不像 KProbe 那样设置单步执行。在返回时，控制权转到用户定义的函数，这样就可以访问原始函数的参数。在用户定义的函数完事后，该调用 jprobe_return() 函数，而不是做普通的 return。\n第二步，jprobe_return() 函数截断当前栈帧并生成一个断点，通过 do_int3() 函数把控制权转移到 kprobe_handler() 函数。 kprobe_handler() 函数发现生成的断点地址（jprobe_handler() 函数中 int3 指令的地址）没有注册探针，但 KProbes 在当前 CPU 上处于活跃状态。它假设断点一定是 JProbes 生成的，因此调用了它先前保存的 current_kprobe break_hanlder 函数。 break_handler 函数会恢复栈以及在控制权转移到用户定义的函数和返回之前保存的寄存器。\n第三步， kprobe_handler() 函数在已设置 JProbe 的指令处设置单步执行，剩下的一系列步骤与 KProbe 相同。\n可能出现的问题 在 KProbes 处理探针的时候，有可能会出现几个问题。第一种，在 SMP 系统上并行处理几个探针。但，所有的探针都共用一个普通的哈希表，那就需要保护它们避免遭到损坏。因此， kprobe_lock 会串行化对探针的处理。\n如果探针被放置在 KProbes 代码内部会发生另外一种问题，导致 KProbes 递归调用探针处理函数。这个问题已经在 kprobe_handler() 函数中处理，它通过检查 KProbes 是否已经在当前 CPU 上运行。这种递归探针会被悄悄的禁掉，并且控制权会返回到先前的探针处理函数。\n如果正在执行 KProbes 的时候发生抢占，在处理探针期间，上下文可以切换到另外一个进程。在先前的探针完全没有处理完的时候，其它的进程可能会触发另一个探针，控制权将再一次转到 kprobe_handler() 函数。当 KProbes 发现新探针正在递归的时候，可能会撤销它。为了避免这个问题，在处理探针的期间抢占是被禁用的。\n同样地，中断被禁用，是因为断点和调试函数是通过中断门调用的，而不是陷阱门。一旦控制权转移到断点或者调试函数就会禁用中断。这些操作是在 arch/i386/kernel/traps.c 文件中做的。\n在处理探针期间可能会发生故障。如果在用户已经定义了一个故障处理函数的情况下，控制权会被转移到故障处理函数。如果用户定义的故障处理函数返回 0 ，那么这个错误由内核来处理。此外， KProbes 会假设故障已经被处理，控制权会回到探针处理函数。\n结论 KProbes 一个极好的调试、追踪工具，也可用来测量性能。开发者可以用它来追踪他们的程序在内核中的路径，以便调试。系统管理员可以用它在生产系统中追踪内核的事件。KProbes 也可以用于非关键性性能测量。不过，目前 KProbes 的实现，在处理探针的过程中引入一些延迟。延迟背后的原因是只有一个 kprobe_lock，它在 SMP 机器上串行化了探针的执行。另外一个因素是 KProbes 使用的机制，它使用多个异常去处理一个探针。异常处理是非常昂贵的操作，会导致延迟。需要在这方面展开工作，提升 SMP 的可扩展性，缩短处探针的处理时间，使得 KProbes 成为可行的性能测量工具。\n但是，KProbes 不能直接用来做这些事情。原始的状态下，用户可编写一个实现探针函数的内核模块。不过，为了更方便的使用它，必须使用更高级的工具。这种高级工具可以包含标准的探针函数，用它们来实现所要的功能，或者它们可以包含一种类似 DProbes 的脚本语言，用来生成 probe-handlers。\n相关链接  KProbes 一篇关于 KProbes 的介绍性文章，以及一些如何使用它的例子（译注：此链接已经失效） DProbes Linux 基于 KProbes 的脚本化追踪工具 Network Packet Tracing Patch 这个补丁能让 Dprobes 追踪网络数据包经过内核栈的路径 KProbes debugfs patch 这个补丁列出所有探针，它们都可以通过 debugfs 应用在任意地址上（译注：此链接已失效） SysRq key for KProbes Patch 这个补丁能够让 SysRq 键列出所有已应用的探针（译注：此链接已失效） SystemTap Linux 内核追踪工具 - 正在开发中  致谢 作者要感谢他的编辑们 Jonathan Corbet, Kalyan T.B. (HP), Siddharth Seth (IIITB) 和 Bharata B. Rao (HP) 审阅这篇文章以及给出了他们的反馈、意见、建议等等，并帮助改进这片文章。\n","description":"","id":1,"section":"posts","tags":["kprobe"],"title":"译｜2005｜ An Introduction to Kprobes","uri":"https://jayce.github.io/public/posts/kprobes/an-introduction-to-kprobes/"}]