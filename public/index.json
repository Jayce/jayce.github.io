[{"content":"CentOS7 默认情况下，用 rpmbuild 命令制作 RPM 包，还会额外自动生成一个 debuginfo 的 RPM 包，无需多做配置。这个 debuginfo 包很有用， GDB、Systemtap 等调试工具都需要它，没理由不需要它。\n不过，凡事总会有例外，如果么有按照 rpm 的标准流程构建 rpm 包，可能就不会自动生成。要找出”为什么不自动生成“的原因，可以先捋一捋“怎么自动生成”。\n先捋捋，如果查过怎么禁止生成 debuginfo 的办法的话，那大体上知道有这么个 %{debug_package} 宏，它其实是个子包，同时存在 spec 文件中，不过并不是手动添加的，而是在构建时自动加到 spec 文件里面的，或者说是自动展开的。\n而所有的宏几乎都是定义在 /usr/lib/rpm 目录里面，找线索就搜索这个目录就好。先找到 %{debug_package} 宏的定义，它位于 /usr/lib/rpm/redhat/macros 文件中：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  # Template for debug information sub-package. # NOTE: This is a copy from rpm to get the ifnarch noarch fix, it can be removed later %debug_package \\ %ifnarch noarch\\ %global __debug_package 1\\ %package debuginfo \\ Summary: Debug information for package %{name}\\ Group: Development/Debug\\ AutoReqProv: 0\\ %description debuginfo\\ This package provides debug information for package %{name}.\\ Debug information is useful when developing applications that use this\\ package or when debugging this package.\\ %files debuginfo -f debugfiles.list\\ %defattr(-,root,root)\\ %endif\\ %{nil} %install %{?_enable_debug_packages:%{?buildsubdir:%{debug_package}}}\\ %%install\\ %{nil}   分析一下这个宏的构成：添加了一个 %package 宏，定义了一个全局宏 __debug_package，定义了打包阶段的命令 debuginfo -f debugfiles.list。总体意思就是打包 debugfiles.list 文件中的包含文件列表。\n什么情况下会自动添加这个 %debug_package？紧挨着定义，它是被 %{install} 宏引用了。\n意思是会在 %install 阶段执行，不过这里有逻辑判断，检查了 %buildsubdir 和 %_enable_debug_packages 是不是有值。\n先找找 %{buildsubdir} 的定义，它是在 %setup 之后才有值，默认值是 %name-%version，也可以传入参数改变。\n1 2 3 4 5 6 7 8 9 10  #============================================================================== # ---- Optional rpmrc macros. # Macros that are initialized as a side effect of rpmrc and/or spec # file parsing. # # The sub-directory (relative to %{_builddir}) where sources are compiled. # This macro is set after processing %setup, either explicitly from the # value given to -n or the default name-version. # #%buildsubdir   再看看 _enable_debug_packages 的定义，在 /usr/lib/rpm/redhat/macros 文件中找到，它的值默认就是 1。\n%_enable_debug_packages 1 %_include_minidebuginfo 1 这样的话，那关键点就落在了 %{buildsubdir} 宏，而如果只要是按照正常逻辑写的 spec 文件，其中就是有 %setup 宏，就满足了自动添加 %{debug_package} 宏的条件。关系清楚了。\n%{setup} 宏用途是解压包，而我的环境中是跳过了解压，直接转到源码目录编译的。原因，就是因为没有使用 %setup 宏。\n继续。如果没有使用 %setup 宏，主动给 %{buildsubdir} 设置一个值，我的构建过程应该就可以了。看注释，它的值应该是一个 %{_builddir} 的子目录。\n搜索下 %{_builddir} 宏定义，它的值是顶级目录下的 BUILD 子目录。这目录是用来编译的，不是用来打包的。%setup 会把源码解压到一个 %name-%version 的子目录。\n1 2  # The directory where sources/patches will be unpacked and built. %_builddir %{_topdir}/BUILD   我的 case 因为是通过别的方式编译的，所以需要把编译好的的可执行文件放到这样的子目录里面，然后设定好 %{_buildsubdir} 的值，应该就可以工作了。我在编译时添加指令 --define \u0026quot;_buildsubdir %name-%version\u0026quot; 了。不过没有使用 %setup 宏，就要事先创建好子目录，并把编译好的文件复制子目录中。\n%debug_package 宏定义中还定义了一个 %__debug_package 宏，查看下它有什么用途。在 /usr/lib/rpm/macros 文件中。\n1 2 3 4 5  %__spec_install_post\\ %{?__debug_package:%{__debug_install_post}}\\ %{__arch_install_post}\\ %{__os_install_post}\\ %{nil}   %__spec_install_post 宏是在 %{install} 之后执行的，主要目的是生成 debuginfo 文件。而 %install 阶段其实是要把可执行文件安装到 %{buildroot} 路径中。\n搜索 %__debug_install_post 宏，在 /usr/lib/rpm/macros 文件中找到。\n1 2 3  %__debug_install_post \\  %{_rpmconfigdir}/find-debuginfo.sh %{?_missing_build_ids_terminate_build:--strict-build-id} %{?_include_minidebuginfo:-m} %{?_find_debuginfo_dwz_opts} %{?_find_debuginfo_opts} \u0026#34;%{_builddir}/%{?buildsubdir}\u0026#34;\\ %{nil}   find-debuginfo.sh 脚本会搜索哪些可执行文件含有调试符号，另外还使用了之前的两个宏 %{_builddir}/%{buildsubdir}。脚本内容就不细查了，只知道这个脚本会生成一些文件，比如 \u0026ldquo;debugfiles.list\u0026rdquo; 文件，可以在 %{_builddir}/BUILD 目录中找到。\n回头再看看 %debug_package 的定义（这里去掉了目前不用关心的内容）：\n1 2 3 4 5 6 7  %debug_package \\ ..... ..... %files debuginfo -f debugfiles.list\\ %defattr(-,root,root)\\ %endif\\ %{nil}   这里的 %files 宏会把 debugfiles.list 里面的文件打包到 debuginfo 包里。\n至此基本上就分析完了，自己的问题也解决了。\n最后，就是平时编辑 spec 文件的时间不多，语法和逻辑感觉也有点怪，而开源软件几乎都不提供各种平台包管理器的 spec 文件，经过这么分析一通，似乎也有点理解。\n也难怪会有一个 fpm 项目把其他平台所有的包封装过程改成了参数和命令，使用起来简单，只需要记住几个参数就行了。但相对的，对于某种格式独有的特性并不完全支持、兼容，如果不用某些特有的功能，算是很简单的。 fpm 目前就不支持自动生成 debuginfo ，它生成的 spec 文件中把关键的几个打包阶段都给禁止了。\n难办！\n","description":"","id":0,"section":"posts","tags":["rpmbuild"],"title":"为什么没有 debuginfo-xxx.rpm ？","uri":"https://jayce.github.io/public/posts/misc/why-no-debuginfo-rpm/"},{"content":"起因 起因是对一个旧项目的技术更迭。这种项目的初期，自然是要花了很长的时间来做调研。因为都是 HTTP 协议，可以先抓包观察请求和响应的内容，从中找到异样的点。\n偶然抓到了带 Range 的请求，且不是常见的 Range: bytes=18099184-18165549 格式。随问了，什么场景需要读取同一个资源的不同位置的数据呢？无果，只能先记下。然后，对于这种项目肯定要秉持一种原则，就是得支持，不然 \u0026mdash; 。\n支持应该也不是很难，先来感受一下：\n1 2 3 4 5 6 7 8 9 10 11  \u0026gt; GET ********** HTTP/1.1 \u0026gt; .... \u0026gt; Range: bytes=18099184-18165549,392163-395061,107934-110397,98322-98498, \u0026gt; 200261-202919,590655-596843,100554-103007,105471-107933,256379-259075, \u0026gt; 115337-117812,171343-173950,103008-105470,267181-269885,512861-517579, \u0026gt; 349450-352216,275312-278038,232237-234909,327379-330130,14248467-14300167, \u0026gt; 221556-224221,330131-332882,125348-127866,435522-439086,291708-294446, \u0026gt; 297186-299925,166145-168736,261776-264475,380585-383472,412567-415595, \u0026gt; 117813-120318,313638-316383,9446656-9482385,269886-272595,415596-418738, \u0026gt; 316384-319131,806912-814940,242936-245614,324629-327378,321880-324628,208239-210900 \u0026gt; ...   术语  这里的两个词是平时沟通中使用的，意思是把属性附加到请求上了，指的是一种请求。实际上在 HTTP 协议里面称为 single-part 或是 multiple-parts 。\n   single-range\n指 HEADER 中带有 “Range: bytes=0-2” 内容的请求。服务端如果可以满足字节范围，就响应 206 并发送对应 “Range” 所指的内容给客户端。书写格式为：Range: \u0026lt;unit\u0026gt;=\u0026lt;range-start\u0026gt;-。\n  multi-ranges\n与 single-range 一样，只不过 HEADER 变成了 “Range: bytes=0-2,3-4,10-20” 。同样的，如果服务端能够满足这些字节范围，就可以响应 206 ，但是把内容封装成 multipart/byteranges;boundary=THIS_STRING_SEPARATES 格式，再发送给客户端。书写格式为：Range: \u0026lt;unit\u0026gt;=\u0026lt;range-start\u0026gt;-\u0026lt;range-end\u0026gt;, \u0026lt;range-start\u0026gt;-\u0026lt;range-end\u0026gt;, \u0026lt;range-start\u0026gt;-\u0026lt;range-end\u0026gt;\n  两种情况的区别就是传输格式不同。single-range 的内容读到的就是实际内容。相反，读到 multi-rangs 的内容后还需要做一点点解码工作。当然这个解码工作其实非常简单，而现在 HTTP 非常流行，各种库或者框架应该都封装好了，应该也不用操心。\n同源 好在以前项目是基于非常旧的 1.2.x 的 nginx 源码的，而新的技术栈基于 openresty ，本质上是一样的。\nNginx 的 range 模块是支持 multi-ranges 请求的，该模块在 body_filter 阶段把输出的内容按照 ranges 的范围进行重新拼装。不过目前只能对静态文件有效，并且其内容只能用一个 buf 来表示。\nNginx 的 slice 模块支持了一种分片机制，与缓存机制同时使用会有比较好的效果，等于可以缓存资源的某个片段。启用这个特性之后，对于 nginx 内部来讲一个资源可就变成多个相互独立的资源了。Nginx 在加入 slice 模块的时候对 range 模块也做了相应的修改，不过只支持了 single-range 。\n我做调查的时候就在想，为啥当时不把 multi-ranges 一起给实现了呢？；使用的场景？没想出来；断点续传？也没有这样做续传的吧。\n目前的情况是，slice 好用，得开；有这类请求，得支持。\n事前分析 Nginx 作为代理，为了尽快让客户端得到反馈，设计了一个流式输出机制。这个机制可以把收到的 upstream 的数据同步发送给 downstream 。数据流必经之地就是 body_filter 阶段，想要对内容做手脚的模块就必须挂载到这个阶段。\n这个阶段最重要的参数就是 ngx_chain_t 对象，它是一个把 ngx_buf_t 串联起来的链表结构。每个 body_filter 实际上就是在调整这个链表的长度或者是修改 buf 的内容。\nNginx 把输出内容的一些状态（什么时候没内容了）放到了 ngx_buf_t 结构体中，用位标记表示，实际在处理链表的时候，是要调整 buf 的标记位的。有个重要的标记：buf-\u0026gt;last_buf ，其表示的就是链表中最后一个 buf ，不会再有内容了。\n再看看 range 模块，实际上就是在遍历链表，找到 start 所在的 buf，把不满足 start 的 buf 删除，再找到 end 所在的 buf ，设置 buf-\u0026gt;last_buf 并把之后的节点删除。另外，遍历过程中，需要把迭代过的 buf 标记位重置，这是因为可能会有别的模块设置了，比如 slice 模块。\n再再看看 slice 模块加进来之后 range 模块有什么改动，对应的提交记录。这次提交最核心的地方就是 ctx-\u0026gt;offset = r-\u0026gt;headers_out.content_offset; 这行代码，这是表示了响应内容的偏移量。主要用途就是支持 slice 的分片请求，因为这种响应内容是从某个固定的偏移开始的，那 range 模块必须要知道是从哪里开始的。\nslice 还必须分析请求 HEADER 中的 Range ，以便知道应该从哪里开始，并把启始偏移量设置到 r-\u0026gt;headers_out.content_offset ，这样 range 模块就知道上下文了。另外， slice 只是针对发送到上游的请求，所以无论 Range 的值是不是合法的，都会工作。对于不合法的 Range 由 range 模块来处理。\nslice 的实现利用了内部子请求机制。子请求对于模块来说与正常请求没什么不同，什么意思？意思是子请求也有输出链。会把一个请求拆成了多个子请求，并且按顺序发送给 upstream ，且所有的 body_filter 模块都会处理子请求的内容。slice_header_filter 会调整 r-\u0026gt;headers_out.content_offset 的值；range_body_filter 会根据 r-\u0026gt;headers_out.content_offset 来调整主请求和子请求的输出链。slice_body_filter 要对输出链内容需要做调整，就是把最后一个 buf 的 last_buf 标记清除了，不然会提前中止主请求。其他处理（拼接输出链）交给子请求的一个核心模块来处理（postpone）。\nslice 模块在主请求中调整偏移量\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33  r-\u0026gt;headers_out.status = NGX_HTTP_OK; r-\u0026gt;headers_out.status_line.len = 0; r-\u0026gt;headers_out.content_length_n = cr.complete_length; // 整个内容的长度  r-\u0026gt;headers_out.content_offset = cr.start; // content_offset 在 range 模块中使用  r-\u0026gt;headers_out.content_range-\u0026gt;hash = 0; r-\u0026gt;headers_out.content_range = NULL; ..... rc = ngx_http_next_header_filter(r); /* 跳过子请求，不需要计算 */ if (r != r-\u0026gt;main) { return rc; } /* 主请求中对齐 range 请求的范围 * content_offset 被 range 模块修改了，改成了请求实际需要的启始位置 * content_length_n 被 range 模块修改成了实际需要的内容长度 * 也因此这里需要重新校对一下 start 和 end，避免发送多余的子请求 */ if (r-\u0026gt;headers_out.status == NGX_HTTP_PARTIAL_CONTENT) { if (ctx-\u0026gt;start + (off_t) slcf-\u0026gt;size \u0026lt;= r-\u0026gt;headers_out.content_offset) { ctx-\u0026gt;start = slcf-\u0026gt;size * (r-\u0026gt;headers_out.content_offset / slcf-\u0026gt;size); } ctx-\u0026gt;end = r-\u0026gt;headers_out.content_offset + r-\u0026gt;headers_out.content_length_n; } else { ctx-\u0026gt;end = cr.complete_length; }   改进思路 根据 slice 的实现分析，只处理了 single-range 的请求，那么要支持 multi-ranges 只需要把表示 range 的结构体变成数组就可行了吧？\n HTTP/1.1 206 Partial Content Date: Wed, 15 Nov 1995 06:25:24 GMT Last-Modified: Wed, 15 Nov 1995 04:58:08 GMT Content-Length: 1741 Content-Type: multipart/byteranges; boundary=THIS_STRING_SEPARATES --THIS_STRING_SEPARATES Content-Type: application/pdf Content-Range: bytes 500-999/8000 ...the first range... --THIS_STRING_SEPARATES Content-Type: application/pdf Content-Range: bytes 7000-7999/8000 ...the second range --THIS_STRING_SEPARATES-- multi-ranges 与 single-range 不同点在于对内容的封装格式，而响应 HEADER 是事先在 range_header_filter 阶段就准备好了的，后面发送就好。要实现，意味着需要记录 multi-ranges 中每个 range 的处理状态，未处理、处理了一半、已处理？。\nnginx 支持的 multi-ranges 非常灵活，Range 内容可以是 -10, 10-, 0-10 这种。加上 slice 之后 body_filter 阶段得到的输出链，可能只包含一点内容，不够一个 range 。\n这就要 slice 模块根据 Range 值的顺序发起子请求，等某个 range 的内容满足之后，重置状态，再处理下一个，直到结束。range 模块实际也要按照相同的逻辑来处理，只需要保证处理完一个 range 之后，把剩余 buf 内容清掉，另外还要考虑内容封装的逻辑，这部分内容实际也会写入 buf 。\n其实还可以考虑把 range 合并，这样发送给 upstream 的请求会少一些，不过这会让 range 模块的实现变得复杂。\n摸一摸几个层次的上下文之后，想法是不是会自然的浮现？\n","description":"","id":1,"section":"posts","tags":["nginx"],"title":"Nginx Slice 模块支持 multi-ranges","uri":"https://jayce.github.io/public/posts/nginx/multi-ranges-with-slice/"},{"content":"译者序 在 Linux 系统上用来追踪、调试的工具有很多，有内核态的、用户态的、网络、IO 等等不同层次的工具。本文翻译自 Linux tracing systems \u0026amp; how they fit together - Julia Evans，这是在学习 Systemtap 原理时找到的资料，文章中就粗略讲了 Linux 的追踪系统，以及一点点来龙去脉，实际上工作中用到的大部分工具或多或少都是基于文章当中提到的某一种机制实现的。\n注：因为水平有限，文中难免存在遗漏或者错误的地方。如有疑问，建议直接阅读原文。\n我对于 Linux 追踪系统一直很困惑，有好几年了。strace、ltrace、kprobes、tracepoints、uprobes、ftrace、perf、eBPF，它们怎么串联在一起的，又有什么意义呢？\n上周，我去了\u0026rdquo;Papers We Love\u0026quot;1，后来我 \u0026amp; Kamal 到蒙特利尔理工大学（LTTng 项目开始的地方）与 Suchakra 一起出去玩，终于我想我理解了所有的这些部件是如何组合在一起的了，或多或少吧。不过，在这篇文章中依然会有一些错误，如果发现了请让我知道！（twitter ID：b0rk）。\n这篇文章我要把 strace 抛开（它是我最喜欢的工具），因为开销太高了 - 在这篇文章中我们只会讨论相对高效/低开销的追踪系统。这篇文章也不是关于样本采集器的（这是另外一个主题！）。只是追踪。\n我上周学到的东西帮助我真正的了解了 —— 你可以把 linux 追踪系统拆分为数据源（追踪数据的来源），收集数据源的机制（类似 ftrace）和追踪前端（以交互式方式收集/分析数据的工具）。整体看上去还有些零散和模糊，但至少是一个更容易理解的方法。\n以下是我们将要讨论的内容：\n 图片版本 能追踪什么？ 数据源：kprobes, tracepoints, uprobes, dtrace probes 等等  kprobes uprobes USDT/dtrace probes kernel tracepoints lttng-ust   收集\u0026quot;真香\u0026quot;数据的机制  ftrace perf_events eBPF sysdig systemtap LTTng   前端  perf 前端 ftrace 前端 eBPF 前端: bcc LTTng \u0026amp; SystemTap 前端   所以我应该使用什么样的追踪工具 希望这篇文章有用！  这仍然有点复杂，但以这样的方式分解它，确实有助于我理解（感谢 Brendan Gregg 在 Twitter 上建议这样分解！）\n图片版本 这里有 6 个草图，汇总了这篇文章的内容：\n  数据源、提取方法、前端\n  数据源：kprobes、uprobes、tracepoints、USTD\n  提取方法：ftrace 文件系统、perf_event 系统调用、eBPF 程序\n  更多方式：Systemtap 脚本、LTTng 工具、sysdig 命令\n  前端：更容易使用、更友好的显示数据\n  更现代的前端\n  能追踪什么？ 你也许想要追踪几种不同类型的事情：\n 系统调用 Linux 内核函数调用（TCP 栈中的哪个函数正在被调用？） 用户空间函数调用（malloc 被调用了吗？） 在用户空间或是内核空间自定义的\u0026quot;事件\u0026rdquo;  以上所有事情都是可能的，不过追踪环境实际上是非常复杂的。\n数据源：kprobes, tracepoints, uprobes, dtrace probes 等等 Okay，让我们谈谈数据源！这是最有意思的部分——有太多地方可以获取程序的数据。\n我要把它们分成 \u0026ldquo;probes\u0026rdquo;（kprobes/uprobes）和 \u0026ldquo;tracepoints\u0026rdquo;（USDT/kernel tracepoints/ltng-ust）。实际上，我认为我没有使用正确的术语，这有 2 个不同的概念能帮助你去理解。\n\u0026ldquo;probe\u0026rdquo; 是一种机制，内核可以在运行时修改你的汇编程序（类似，改变指令）来开启追踪。这点非常强大（有点可怕！），因为可以在你追踪的程序任意指令上启用一个 probe。（不过 dtrace probes 不是这种形式的 \u0026ldquo;probes\u0026rdquo;）。Kprobes 和 uprobes 就是这种形式的例子。\n\u0026ldquo;tracepoint\u0026rdquo; 是一种编译到你的程序中的东西。当使用程序的人，想要看看 tracepoint 什么时候命中及提取数据的时候，他们可以先\u0026quot;启用\u0026quot;或\u0026quot;激活\u0026rdquo; tracepoint 。通常，在 tracepoint 没有被激活的时候不会产生任何额外的开销，甚至在它被激活的时候开销也是相当的低。USDT（\u0026ldquo;dtrace probes\u0026rdquo;）、lttng-ust 、kernel tracepoints 它们都是这种模式的例子。\nkprobes 接下来是 kprobes！那是什么？下面这段话来自 LWN 的一篇文章:\nKProbes are a debugging mechanism for the Linux kernel which can also be used for monitoring events inside a production system. You can use it to weed out performance bottlenecks, log specific events, trace problems etc. --  KProbes 是一种 Linux 内核调试机制，也可以用来监控生产系统内部的事件。还能用它来发现性能瓶颈、记录特定的事件、追踪问题等等。\n 复述一下，基本上 kprobes 能让你在运行时动态的改变 Linux 内核的汇编代码（比如，插入额外的汇编指令），追踪一个指令什么时候被调用。我以为 kprobes 就是追踪 linux 内核函数调用，实际上它可以追踪内核中的任意指令以及检查寄存器。神奇吧？\nBrendan Gregg 有个 krpobe 脚本，可以用来玩一玩 krpboes。\n例如！让我们用 kprobes 追踪，我们电脑上正在打开的文件。我执行了下面这条命令\n1  $ sudo ./kprobe \u0026#39;p:myopen do_sys_open filename=+0(%si):string\u0026#39;   之后，我的电脑立即输出正在打开的文件。干净整齐！\n你会注意到 kprobes 接口本身有点晦涩 - 比如，你必须知道给 do_sys_open 的 filename 参数是在 %si 寄存器中，还要取消对这个指针的引用，并告诉 kprobes 系统它是一个字符串。\n我认为 kprobes 在以下 3 种情况中很有用：\n 你正在追踪一个系统调用。所有系统调用都有对应的内核函数，比如：do_sys_open。 你正在调试一些网络栈或者文件 IO 的性能问题，且足够了解被调用的内核函数，对你追踪它们很有帮助（不是不可能！毕竟 linux 内核也是代码）。 你是一名内核开发者又或者在试着调试不常发生的内核 bug ！（我不是一名内核开发者）  uprobes Uprobes 有点像 kprobes，只不过它不是检测内核函数的，而是检测用户空间函数的（例如 malloc）。可以阅读 brendan gregg 在 2015 年发布的一篇文章.\n我对 uprobes 工作原理的理解是：\n 你决定想要去追踪在 libc 中的 malloc 函数 你要求 linux 内核为你追踪 libc 中的 malloc 函数 Linux 找到 libc 被加载到内存中的副本（应该只有一份，共享给所有进程），然后改变 malloc 的代码方便被追踪 Linux 用某种办法把数据传递给你（稍后我们会谈怎么\u0026quot;要求 linux\u0026quot;以及\u0026quot;用某种办法获取数据\u0026quot;的原理）  你可以用它做的一件事情是监视其他人在他们的 bash 终端中输入的内容，很炫哝！\n1 2 3 4 5 6 7 8  [email protected]~/c/perf-tools\u0026gt; sudo ./bin/uprobe \u0026#39;r:bash:readline +0($retval):string\u0026#39; Tracing uprobe readline (r:readline /bin/bash:0x9a520 +0($retval):string). Ctrl-C to end. bash-10482 [002] d... 1061.417373: readline: (0x42176e \u0026lt;- 0x49a520) arg1=\u0026#34;hi\u0026#34; bash-10482 [003] d... 1061.770945: readline: (0x42176e \u0026lt;- 0x49a520) arg1=(fault) bash-10717 [002] d... 1063.737625: readline: (0x42176e \u0026lt;- 0x49a520) arg1=\u0026#34;hi\u0026#34; bash-10717 [002] d... 1067.091402: readline: (0x42176e \u0026lt;- 0x49a520) arg1=\u0026#34;yay\u0026#34; bash-10717 [003] d... 1067.738581: readline: (0x42176e \u0026lt;- 0x49a520) arg1=\u0026#34;wow\u0026#34; bash-10717 [001] d... 1165.196673: readline: (0x42176e \u0026lt;- 0x49a520) arg1=\u0026#34;cool-command\u0026#34;   USDT/dtrace probes USDT 全称为\u0026quot;用户级静态定义的追踪\u0026rdquo;，\u0026ldquo;USDT 探针\u0026rdquo; 和 \u0026ldquo;dtrace 探针\u0026quot;是一个东西（有点出乎我的意料！）。你也许已经听过 BSD/Solaris 上 dtrace，其实你也能在 Linux 上用 dtrace 探针。其实，它是一种暴露自定义事件的方法。举个例子，假如你编译正确的话， Python 3 是有 dtrace 探针的。\npython.function.entry(str filename, str funcname, int lineno, frameptr)\n如果有一个能够消费 dtrace 探针的工具（例如： eBPF/systemtap），和支持 dtrace 的 Python 版本，你就可以自动的追踪 Python 函数调用。很棒对吧！（然而这是一种\u0026quot;假设\u0026rdquo;————并不是所有编译的 Python 都支持 dtrace 探针的，在 Ubuntu 16.04 中的 Python 就不支持）\n怎么判断支不支持 dtrace 探针，根据 Python 文档，其实你可以用 readelf 工具在二进制文件中查找的 \u0026ldquo;stap\u0026rdquo; 字符串。\n1 2 3 4 5 6  $ readelf -S ./python | grep .note.stapsdt [30] .note.stapsdt NOTE 0000000000000000 00308d78 # sometimes you need to look in the .so file instead of the binary $ readelf -S libpython3.3dm.so.1.0 | grep .note.stapsdt [29] .note.stapsdt NOTE 0000000000000000 00365b68 $ readelf -n ./python   如果想阅读更多关于 dtrace 的内容，你可以阅读 2004 年的论文，不过我不知道是不是最好的参考。\nkernel tracepoints Tracepoints 也在 Linux 内核中（这有篇LWN 的文章）。这个方法是 Mathieu Desnoyers（他来自 Montreal！）写的。简单来讲，有一个 TRACE_EVENT 宏，它能让你定义追踪点，像下面这样（它对 UDP 失败队列做些事情？）\n1 2 3 4 5 6 7  TRACE_EVENT(udp_fail_queue_rcv_skb, TP_PROTO(int rc, struct sock *sk), TP_ARGS(rc, sk), TP_STRUCT__entry( __field(int, rc) __field(__u16, lport) ),   我不太明白它是怎么工作的（我认为它涉及面很广），但基本上追踪点：\n 比 kprobes 好的一点，因为它们在内核版本之间更稳定（kprobes 依赖内核代码）（译注：换句话说就是不同内核版本函数会有很大变化，而 kprobes 又依赖于内核符号） 比 kprobes 差的一点，因为必须有人维护它们（译注：一般是内核开发人员或者是模块开发人员在关键的位置放置追踪点，以便可以读取关键数据）。  lttng-ust 我还不太了解 LTTng，但我的理解是，以上 4 种东西（dtrace probes，kprobes，uprobes，tracepoints）在某种程度上都需要内核的支持。lttng-ust 是一个追踪系统，它能让你把追踪探针编译到你的程序中，而且所有追踪都发生在用户空间。意味着它更快开销更小，因为你不必做上下文切换。我还没使用过 LTTng，所以这些就是我要说的内容。\n收集\u0026quot;真香\u0026quot;数据的机制 要理解你用来收集\u0026amp;分析追踪数据的前端工具，理解把内核中的追踪数据取出来的基础机制是非常重要的。（这就只有 ftrace、perf_events、eBPF、systemtap、lttng 5 个工具）。\n让我们从 ftrac，perf_events，eBPF 开始，实际上它们是 Linux 内核的一部分。\nftrace 上面的 ./kprobe 和 ./uprobe 脚本？它们都使用 ftrace 从内核中获取数据。Ftrace 有点像一种名称接口，直接使用它有点痛苦。在 /sys/kernel/debug/tracing/ 内有个文件系统，能让你从内核中获得各式各样的追踪数据。\n与 ftrace 交互的基本方法是：\n 把数据写入在 /sys/kernel/debug/tracing/ 中的文件 从 /sys/kernel/debug/tracing/ 中的文件读出数据  Ftrace 支持：Kprobes、Tracepoints、Uprobes，我认为就是这样。\n基于下面 Ftrace 的输出很难做分析：\n1 2 3 4 5 6  bash-10482 [002] d... 1061.417373: readline: (0x42176e \u0026lt;- 0x49a520) arg1=\u0026#34;hi\u0026#34; bash-10482 [003] d... 1061.770945: readline: (0x42176e \u0026lt;- 0x49a520) arg1=(fault) bash-10717 [002] d... 1063.737625: readline: (0x42176e \u0026lt;- 0x49a520) arg1=\u0026#34;hi\u0026#34; bash-10717 [002] d... 1067.091402: readline: (0x42176e \u0026lt;- 0x49a520) arg1=\u0026#34;yay\u0026#34; bash-10717 [003] d... 1067.738581: readline: (0x42176e \u0026lt;- 0x49a520) arg1=\u0026#34;wow\u0026#34; bash-10717 [001] d... 1165.196673: readline: (0x42176e \u0026lt;- 0x49a520)   perf_events 从内核中获取数据的第二种方法，是使用 perf_event_open 系统调用。原理是：\n 调用 perf_event_open 系统调用 内核写把事件到一个在用户空间的环形缓冲区中，应用程序可以从中读取数据  我知道的唯一的一件事情是，你可以以这种方式读取 tracepoints。这也就是执行 sudo perf trace 命令时做的事情（每个系统调用都有一个 tracepoints）\neBPF eBPF 是一种非常先进的获取数据的方式。它的工作原理。\n 你写一段 \u0026ldquo;eBPF 程序\u0026rdquo;（通常是 C 语言，或者用一种生成这种程序的工具） 要求内核把探针附着到 kprobe/uprobe/tracepoint/dtrace 探针 \u0026ldquo;eBPF 程序\u0026quot;把数据输出到一个 eBPF map/ftrace/perf 缓冲区 你拥有了自己的数据！  eBPF 非常好，因为它是 Linux 的一部分（不用安装内核模块），而且你可以定义自己的程序，去做任何你想做的奇怪的事情，因此它非常强大。平时是通过 bcc 前端间接使用它，稍后再讨论 bcc。不过 eBPF 只在较新的内核上可用（选择内核的哪个版本，取决于想把 eBPF 程序附着到什么样的数据源）\n不同的内核版本提供不同的 eBPF 特性，以下是一份很好的总结：\n sysdig Sysdig 是一个内核模块 + 追踪系统。它能让你追踪系统调用和一些其他的事情？我发现他们的站点有点难用，不过我认为这个文件包含所有 sysydig 支持的事件列表。Sysdig 会告诉你正在打开文件描述符，但不告诉你 TCP 栈的内部细节。\nsystemtap 我对 SystemTap 的工作原理有点不清楚，所以我们从架构文档开始\n 你决定要追踪一个 kprobe 编写一个 \u0026ldquo;systemtap 程序\u0026rdquo;，把它编译到一个内核模块中 内核模块在插入后，在激活时会从你的内核模块中调用代码创建 kprobes（调用 register_kprobe） 内核模块（使用 relayfs or something）打印输出到用户空间  SystemTap 支持：tracepoints、kprobes、uprobes、USDT\n支持许多东西！在这篇 选择一个 linux 追踪工具 的文章中对 systemtap 有更多的描述\nLTTng LTTng (linux tracing: the next generation) 是出自 Montreal （巴黎高等理工学院的实验室）！！，让我超级高兴。前几天，我见过一个被称作追踪罗盘的了不起的 demo 工具，它从 LTTng 读取数据。在执行 tar -zxf somefile.tar.gz 命令时，它可以显示程序与系统调用之间的所有 sched_switch 变化过程，而且真的可以以一种非常清晰的方式看见正在发生的事情。\nLTTng 的缺点（类似 SystemTap）是，你必须安装一个内核模块才能使内核的部分正常工作。使用 lttng-ust 时发生的一切都在用户空间，而且没有内核模块（译注：systemtap 会编译出一个内核模块）。\n前端 Okay！该谈前端了！我要把他们按照机制（怎么将数据从内核中取出来）分类，理解起来更容易一点\nperf 前端 这儿唯一简单的前端是 perf 。\nperf trace 迅速为你追踪系统调用。简单，喜欢。实际上，现在 perf trace 是这些前端当中的唯一一个我每天都在使用的工具。（ftrace 这个东西非常强大，但也更难以使用）\nftrace 前端 Ftrace 用起来有点痛苦，因此也有各式各样的前端工具可以帮到你。我还没发现最好的工具，不过可以从下面这些开始：\n trace-cmd 作为 ftrace 的一种前端，你可以用它收集和显示 ftrace 数据。在这篇文章中我写了一点，另外在 LWN 上有一篇关于它的文章 Catapult 能让你分析 ftrace 的输出。最初它是为了分析 Android/chrome 性能，但你也可以只分析 ftrace 。目前为止，唯一要做的事情就是绘制 sched_switch 事件图，以便知道实际是哪些进程在运行，以及它们在哪个 CPU 上。我还没有真的使用过，哪个更好？ kernelshark 消费 ftrace 的输出，只是我还没有尝试过 perf 命令行工具是一个 perf 前端，并且还是一些 ftrace 功能的前端（有点乱）（见 perf ftrace）  eBPF 前端: bcc 我唯一了解的是 bcc 框架：https://github.com/iovisor/bcc。它能够让你编写 eBPF 程序，帮你把它们插入到内核中，然后它会帮你把数据从内核中读出来，让你可以用 Python 脚本来处理。这框架非常容易上手。\n如果你好奇 tcpdump 中的 BPF 和 eBPF 的关系，可以看看前几天我写过一篇它们之间关系的文章。不过我认为最简单的是把它们看作是两个东西就好，因为 eBPF 强大的多。\nbcc 有点怪异，因为你要在 Python 程序内部写一个 C 程序，不过倒是有很多例子可以参考。前几天 Kamal 和我第一次用 bcc 编写了一个非常简单的程序。\nLTTng \u0026amp; SystemTap 前端 LTTng \u0026amp; SystemTap 都有一套它们自己的工具，我不太了解。说真的————这个被称作追踪罗盘的图形工具，它好像真的很强大。它消费一种 LTTng 产生的数据，称作 CTF（\u0026ldquo;通用追踪格式\u0026rdquo;）追踪格式。\nlinux 4.9, probably just learn about eBPF * `perf trace` is good, it will trace system calls with low overhead and it’s super simple, there’s not much to learn. A+. * For everything else, they’re, well, an investment, they take time to get used to. * I think playing with kprobes is a good idea (via eBPF/ftrace/systemtap/lttng/whatever, for me right now ftrace is easiest). Being able to know what’s going on in the kernel is a good superpower. * eBPF is only available in kernel versions above 4.4, and some features only above 4.7. I think it makes sense to invest in learning it but on older systems it won’t help you out yet * ftrace is kind of a huge pain, I think it would be worth it for me if I could find a good frontend tool but I haven’t managed it yet. -- 所以我应该使用什么样的追踪工具 我现在的想法是（你应该知道，我只是刚刚弄清楚它们如何组装在一起的，我不是专家）：\n 如果你计算机中主要运行 \u0026gt; linux 4.9 版本的内核，可能只用学习 eBPF perf trace 它可以追踪系统调用，低开销，且非常简单，么有太多要学的。A+。 至于其他的，都是一种投资，要花些时间来学习。 我认为 kprobes 用来玩玩还是可以的（eBPF/ftrace/systemtap/lttng/ 等方式，对于我来说 ftrace 是最简单的）。能够知道在内核中发生的一切是一种很好的超能力。 eBPF 只在 4.4 以上的内核版本中可用，且有些特性只在 4.7 以上。我想是有意义的，投资学习它，但在比较旧的系统上，它还不能帮助你 ftrace 有点太痛苦了，不过对于我来说如果可以找到一个好的前端工具它是有价值的，但是还没找到  希望这篇文章有用！ 我真的很高兴，现在我了解了（大部分）所有的组件是如何组装在一起的，这篇文章是我在爵士音乐节上的一场免费的表演中写的，听着布鲁斯过的很愉快。\n现在，我知道它们是如何组合在一起的，我认为我可以更轻松的跟进追踪前端的进展！\nBrendan Gregg 的博客中有大量的这些主题中的细节——如果你有兴趣了解 linux 追踪生态中的改进（一直在变化！），那是最好的博客。\n感谢 Annie Cherkaev, Harold Treen, Iain McCoy, David Turner 阅读这篇文章的草稿。\n 译注：Papers We Love 是一个计算机科学论文网站，经常组织线下活动 \u0026#x21a9;\u0026#xfe0e;\n   ","description":"","id":2,"section":"posts","tags":["trace"],"title":"译｜2017｜Linux 追踪系统\u0026如何组合在一起的","uri":"https://jayce.github.io/public/posts/trace/linux-tracing-system-fit-together/"},{"content":"译者序 这篇文章翻译自 SystemTap 项目中 uprobes.txt 文件，此文件描述了 Uprobes 的概念、工作原理、限制等内容。用途跟 Kprobes 一样，用来追踪运行在用户态的应用程序的。看提交历史，这个功能在 2012 年才提交到 Linux 内核中。\n文章最后提供的例子，可以修改来玩一玩。\n注：因为水平有限，文中难免存在遗漏或者错误的地方。如有疑问，建议直接阅读原文。\n概念：Uprobes、Return 探针 Uprobes 能够动态的介入应用程序的任意函数，采集调试和性能信息，且不引起混乱。你可以在任意地址上，指定断点命中时调用的内核函数。\n目前，用户态探针有两种类型： uprobes 和 uretprobes（也叫 return 探针）。可以在应用程序的虚拟地址空间的任意指令上插入 uprobe 。 当用户函数返回的时候触发 return 探针。后续内容会详细的讨论这两类探针的细节。\nregister_uprobe() 注册函数设定要探测的进程，探针插入的位置，以及命中探针时调用什么回调函数。\n通常，基于 Uprobes 的探测工具是被打包成内核模块。最简单的内核模块，初始化函数安装（\u0026ldquo;注册\u0026rdquo;）一个或多个探针，而后在 exit 函数中注销。其实还可以在响应其他事件中注册或注销探针。例如：\n 探针回调函数自身可以注册或注销探针 可以创建 Utrace 回调函数来注册或注销探针，探测特定的进程什么时候派生子进程、克隆线程、执行、进入系统调用、接收信号、退出等等。参考 Documentation/utrace.txt。  Uprobe 是怎么工作的？ 当一个 uprobe 被注册后，Uprobes 会创建一个被探测指令的副本，停止被探测的应用程序，用断点指令替换被探测指令的首字节（在 i386 和 x86_64 上是 int3），之后让应用程序继续运行。（在插入断点的时候，Uprobes 使用与 ptrace 使用的相同的 copy-on-write 机制，这样断点也只影响那个进程，不会影响其他运行相同程序的进程。甚至是被探测的指令在共享库中也一样。）\n当 CPU 命中断点指令的时候，发生了一个 trap，CPU 用户模式的寄存器都被保存起来，产生了一个 SIGTRAP 信号。Uprobes 拦截 SIGTRAP 信号，找到关联的 uprobe。然后，用 uprobe 结构体和先前保存的寄存器地址调用与 uprobe 关联的回调函数。这个回调函数可能会阻塞，但要记住回调函数执行期间，被探测的线程一直是停止的。\n接下来，Uprobes 会单步执行被探测指令的副本，之后会恢复被探测的程序，让它在探测点之后的指令处继续执行。（实际上单步执行原始指令会更简单，但之后，Uprobes 必须移除断点指令。这在多线程应用程序中会引起问题。比如，当另一个线程执行过探测点的时会打开一个时间窗口。）\n被单步执行的指令副本存储在每个进程的\u0026quot;单步跳出（SSOL）区域\u0026quot;中，它是由 Uprobes 在每个被探测进程的地址空间中创建的很小的 VM 区域。\nUtrace 的作用 当先前被取消探测的进程上又注册一个探针的时候，Uprobes 用 Utrace 为进程中每个线程建立了一个追踪\u0026quot;引擎\u0026rdquo;。Uprobes 使用 Utrace \u0026ldquo;静默\u0026quot;机制，在插入或移除断点之前停止所有线程。Utrace 在被探测进程的生命周期中（fork, clone, exec, exit），通知 Uprobes 断点和单步执行陷阱以及其他感兴趣的事件。\nReturn 探针怎么工作的？ 当你调用 register_uretprobe() 函数的时候，Uprobes 在函数的入口处创建一个 uprobe 。当调用被探测函数的时候命中这个探针，Uprobes 会保存 return 地址的一个副本，然后用\u0026quot;蹦床\u0026quot;的地址替换 return 地址 —— 一段包含一个断点指令代码。\n当被探测的函数执行它的 return 指令时，控制转移到蹦床，命中断点。Uprobes 的蹦床回调函数调用与 uretprobe 关联的回调函数，然后把已保存的指令指针设置为已保存的 return 地址，再然后就从 trap 返回后的地方恢复执行。\n蹦床存储在 SSOL 区域中。\npid to determine which thread has hit the probepoint. -- 多线程应用 Uprobes 支持多线程应用的探测。Uprobes 在被探测的应用中没有线程数量的限制。\n在单个进程中的所有线程，使用相同的文本页，所以进程中的每个探针，会影响所有线程；当然，每个线程命中探测点（以及运行回调函数）是相对独立的。多个线程可能同时运行相同的回调函数。如果你想要一个特定的线程或是一组线程运行一个特定的回调函数，那回调函数应该检查 current 或 current-\u0026gt;pid 来确认哪个线程命中了探测点。\n当进程克隆一个新的线程时，该线程自动的共享所有为进程创建的探针。\n要记住，注册或注销探针的时候，要等到 Utrace 停止了进程中的所有线程后，才会插入或删除断点。注册/注销函数在断点已经被插入或移除之后才返回（看下一章节）。\n探针回调函数內注册探针 uprobe 或 uretprobe 回调函数可以调用 Uprobes API 中的任何函数（[un]register_uprobe(), [un]register_uretprobe()）。探针回调函数甚至可以注销它自己。不过，在回调函数中调用的时候，实际的注册/注销操作不会立刻执行。反而，它们会被放入队列，在该探测点已经运行所有回调函数之后执行。在回调函数中，注册/注销函数会返回 -EINPROGRESS。如果在 uprobe 对象中设置了 registration_callback 字段，会在注册/注销操作完成的时候调用。\n已支持的 CPU 架构 uprobes 和 uretprobes 被实现，在下面的架构上：\n i386 x86_64 (AMD-64, EM64T) ppc64 s390x  配置 Uprobes // TODO: 补丁实际上把 Uprobes 配置放在 \u0026ldquo;Instrumentation Support\u0026rdquo; 下面与 Kprobes 一起。需要决定哪个更好。\n在使用 make menuconfig/xconfig/oldconfig 配置内核的时候，确保 CONFIG_UPROBES 设置为 \u0026ldquo;y\u0026rdquo;。在 \u0026ldquo;Process debugging support\u0026rdquo; 下面，选择 \u0026ldquo;Infrastructure for tracing and debugging user processes\u0026rdquo; 开启 Utrace，然后选择 \u0026ldquo;Uprobes\u0026rdquo;。\n确保 \u0026ldquo;Loadable module support\u0026rdquo;（CONFIG_MODULES）和 \u0026ldquo;Module unloading\u0026rdquo; (CONFIG_MODULE_UNLOAD) 都被设置为 \u0026ldquo;y\u0026rdquo;，这样就可以加载或卸载基于 Uprobes 的测试工具模块。\nAPI 参考 Uprobes API 为每种类型的探针分别提供了\u0026quot;注册\u0026quot;和\u0026quot;注销\u0026quot;函数。这有一份这些函数以及相关的探针处理函数的简短说明。例子见文档后半部分。\nregister_uprobe 1 2  #include \u0026lt;linux/uprobes.h\u0026gt;int register_uprobe(struct uprobe *u);   vaddr in the process whose pid is u-pid. When the breakpoint is hit, Uprobes calls u-handler. -- 在 pid 是 u-\u0026gt;pid 的进程中，虚拟地址 u-\u0026gt;vaddr处设置断点。在命中断点的时候，Uprobes 调用 u-\u0026gt;handler。\nregister_uprobe() 调用成功返回 0，如果是在 uprobe 或 uretprobe 回调函数中（因此延迟了）调用返回 -EINPROGRESS，否则返回负的 errno 。\n\u0026ldquo;延迟注册回调\u0026rdquo;，解释了在完成延迟注册后如何通知。\nhandler): -- 用户的回调函数（u-\u0026gt;handler）:\n1 2 3  #include \u0026lt;linux/uprobes.h\u0026gt;#include \u0026lt;linux/ptrace.h\u0026gt;void handler(struct uprobe *u, struct pt_regs *regs);   在断点命中的时候调用，传入指向断点关联的 uprobe 指针 u 和含有保存的寄存器的结构体指针 regs。\nregister_uretprobe 1 2  #include \u0026lt;linux/uprobes.h\u0026gt;int register_uretprobe(struct uretprobe *rp);   u.pid for the function whose address is rp-u.vaddr. When that function returns, Uprobes calls rp-handler. -- 在 pid 是 rp-\u0026gt;u.pid 的进程中，函数地址 rp-\u0026gt;u.vaddr 处创建 return 探针。当该函数返回时，Uprobes 调用 rp-\u0026gt;handler。\nregister_uretprobe() 成功返回 0 ，如果是在 uprobe 或 uretprobe 回调函数中（因此被延迟）调用返回 -EINPROGRESS，否则返回负的 errno。\n\u0026ldquo;延迟注册回调\u0026rdquo;，解释了在完成延迟注册后如何通知。\nhandler): -- 用户的 return 探针回调函数（rp-\u0026gt;handler）：\n1 2 3  #include \u0026lt;linux/uprobes.h\u0026gt;#include \u0026lt;linux/ptrace.h\u0026gt;void uretprobe_handler(struct uretprobe_instance *ri, struct pt_regs *regs);   regs表示用户的 uprobe 处理函数。ri 指向 uretprobe_instance 对象，其关联了当前正在返回的函数实例。可以关注对象中的两个字段：\n ret_addr：return 地址 rp：指向对应的 uretprobe 对象  在 ptrace.h 文件中，regs_return_value(regs) 宏提供了一种简单的抽象，从架构的 ABI 定义的相关寄存器中获得返回值。\nunregister_*probe 1 2 3  #include \u0026lt;linux/uprobes.h\u0026gt;void unregister_uprobe(struct uprobe *u); void unregister_uretprobe(struct uretprobe *rp);   移除探针。注销函数可以在探针注册之后的任何时间调用，还能在 uprobe 或 uretprobe 回调函数中调用。\n延迟注册回调 1 2 3  #include \u0026lt;linux/uprobes.h\u0026gt;void registration_callback(struct uprobe *u, int reg, enum uprobe_type type, int result);   registration_callback for [un]register_uprobe or rp-u.registration_callback for [un]register_uretprobe. Uprobes calls that callback function, if any, passing it the following values: - u = the address of the uprobe object. (For a uretprobe, you can use container_of(u, struct uretprobe, u) to `obtain` the address of the uretprobe object.) - reg = 1 for register_u[ret]probe() or 0 for unregister_u[ret]probe() - type = UPTY_UPROBE or UPTY_URETPROBE - result = the return value that register_u[ret]probe() would have returned if this weren't a delayed operation. This is always 0 for unregister_u[ret]probe(). -- 像前面提到的函数，可以在 uprobe 或 uretprobe 回调函数内部调用。当发生这种情况的时候，注销/注册操作会被延迟，直到与探测点关联的所有回调函数都已运行之后执行。在完成注销/注册操作之后，Uprobes 会检查 uprobe 关联的 registration_callback 成员变量：uprobe 对应 u-\u0026gt;registration_callback 或者 uretprobe 对应 rp-\u0026gt;u.registration_callback。如果存在 Uprobes 会调用 registration_callback 回调函数，并传入下面的值：\n u = uprobe 对象的地址。（uretprobe 对象，可以使用 container_of(u, struct uretprobe, u) 获得 uretprobe 对象的地址。）   reg = 1 for register_u[ret]probe() or 0 for unregister_u[ret]probe() type = UPTY_UPROBE or UPTY_URETPROBE   result = 如果不是延迟操作，作为 register_u[ret]probe() 的返回值。对于 unregister_u[ret]probe() 总是返回 0 。  注意：Uprobes 只在延迟注销/注册的情况下调用 registration_callback。\nUprobes 功能与限制 希望用户给 uprobe 结构体的成员赋值：pid, vaddr, handler, （如果需要）registration_callback。其他保留的成员给 Uprobes 使用。如果做了下面这些事情，Uprobes 可能会产生不期望的结果：\n 把保留的 uprobe 结构体成员设置为非 0 值 在注册期间改变 uprobe 或 uretprobe 对象的内容 注册已注册的 uprobe 或 uretprobe  Uprobes 允许在特定的地址上注册任意数量的探针（uprobes、uretprobe 都可以）。探针回调函数是按照它们注册的顺序调用的。\n任意数量的内核模块可以同时探测一个特定的进程，而特定的模块也可以同时探测任意数量的进程。\nthreads).\n在进程中的所有线程之间的探针是共享的（包括新创建的线程）。\n如果被探测进程退出或执行，Uprobes 会自动注销所有与之关联的 uprobes 和 uretprobes 。之后再注销这些探针将会视为无效。\n另外，如果从进程的虚拟内存映射删除探测的内存区域的话（例如：通过 dlclose(3) 或 munmap(2)），目前需要先主动注销探针。\n没有方法在 fork 进程时继承探针，Uprobes 会在新创建的子进程中移除所有探测点。关于这点更多的信息见\u0026quot;与 Utrace 交互\u0026rdquo;。\n至少在某些架构上，Uprobes 不会尝试校验，指定的探针地址是否是一条指令的开始。如果你弄错了，可能造成会混乱。\n为避免干扰交互式调试工具，Uprobes 会拒绝在已存在断点指令的地方插入探测点，除非是 Uprobes 放那里的。有一些架构可能会拒绝在其他类型的指令上插入探针。\n如果在可内联的函数中插入一个探针，Uprobes 并不会尝试给该函数的所有内联实例插入探针。如果没有命中期望的探针，要记住，gcc 可能会自动内联一个函数。\n探针回调函数可以修改目标函数的环境 ——例如：修改数据结构，或修改 pt_regs 结构体的内容（从断点返回之后保存的寄存器）。因此，Uprobes 可以用来，安装补丁或测试时注入错误。当然 Uprobes 没有办法区分错误是故意注入的还是意外发生的。所以不要搞事情。\n因为 return 探针是通过使用蹦床的地址替换 return 地址实现的，那么栈回溯和调用 __builtin_return_address() 产生的是蹦床的地址，而不是uretprobed 函数的实际 return 地址。\n如果函数调用的次数与 return 次数不匹配（例如：如果函数调用 longjmp() 退出），在这种函数上注册 return 探针，可能会产生不期望的结果。\n当在探测点注册第一个探针或者注销最后一个探针的时候，Uprobes 要求 Utrace 去\u0026quot;暂停\u0026quot;目标进程，这样 Uprobes 就可以插入或者移除断点指令。如果进程还没有停止，Utrace 会停止它。如果进程正在运行一个可中断的系统调用，可能会让系统调用提早完成或失败而产生 EINTR 信号。（ptrace 系统调用的 PTRACE_ATTACH 请求有同样的问题。）\n当 Uprobes 在先前的未探测的页面上建立探测点的时候，Linux 会通过 copy-on-write 机制创建了这个页面的新副本。在移除探测点的时候，Uprobes 并不会尝试合并同一个页面的副本。如果探测在大量长时间运行的进程中探测大量的页面，会影响内存可用性。\n与 Kprobes 交互 Uprobes 打算与 Kprobes 进行有效的相互操作（见 Documentation/kprobes.txt 文件）。例如，检测模块可以同时调用 Kprobes API 和 Uprobes API。\nuprobe 或 uretprobe 回调函数可以注册或注销 kprobes、jprobes、kretprobes，以及 uprobes 和 uretprobes。另外，kprobe、jprobe、kretprobe 回调函数一定不能休眠，不然会无法注册或注销这些探针。（欢迎移除这种限制的想法）\n注意，命中 u[ret]probe 的开销是命中 k[ret]probe 的几倍。\n与 Utrace 交互 在\u0026quot;Utrace 的作用\u0026quot;章节中提到，Uprobes 是 Utrace 的客户端。Uprobes 为每个被探测的线程建立了一个 Utrace 引擎，及为 clone/fork, exec, exit, \u0026ldquo;core-dump\u0026rdquo; 信号（其包括断点陷阱）这类事件创建寄存器回调函数。Uprobes 是在进程首次被探测的时候创建引擎，或者在创建线程时通知，反正先到先处理。\n检测模块可以同时使用 Utrace 和 Uprobes APIs（以及 Kprobes）。这么做的时候，请记住下面的事情：\n 对于特定的事件，Utrace 回调函数是按引擎的创建顺序调用的。目前 Utrace 没有机制来改变顺序。 在 Uprobes 得知目标进程创建了子进程后，会在子进程中移除断点。   在 Uprobes 得知目标进程已经执行或退出后，将会清理这个进程中的数据结构（先允许终止未完成的注销、注册操作）。   当目标线程命中断点或被探测指令单步执行完成的时候，通知已设置 UTRACE_EVENT(SIGNAL_CORE) 标记的引擎。Uprobes 信号回调函数防止（通过 UTRACE_ACTION_HIDE）这个事件，报告给在列表后面的引擎。但，如果你的引擎是在 Uprobes 的引擎之前创建的，还是会收到这个事件。  如果你想在新的子进程中创建探针，可以用以下办法：\n 用 Utrace 注册一个 report_clone 回调函数。在这个回调函数中，以 CLONE_THREAD 标记区分创建新线程还是进程。   在你的 report_clone 回调函数中，调用 utrace_attach() 附着到子进程，以及设置引擎的 UTRACE_ACTION_QUIESCE 标记。子进程将会停顿在准备要探测的位置。   在 report_quiesce 回调函数中，注册所需要的探针。（注意，不能对父子进程使用同一个探测对象。如果想要复制探测点，必须创建一个新的 u[ret]probe 对象集合。）  Here are sample overhead figures (in usec) for different architectures.\n探针开销 // TODO: 已经过时。\n// TODO: 根据其他架构的测试整理。\n在 2007 年常见的 CPU 上，处理 uprobe 命中大约需要3微秒的时间。基准测试反复命中相同的探测点，每次触发一个简单的处理程序，每秒报告 30w-35w 次命中，具体取决于架构。通常，return 探针命中比 uprobe 命中多花 50％ 的时间。当在某个函数上设置了 return 探针，会在该函数的入口处添加 uprobe ，本质上不会增加开销。\n下面是些不同架构的样本（纳秒）。\nu = uprobe; r = return probe; ur = uprobe + return probe i386: Intel Pentium M, 1495 MHz, 2957.31 bogomips u = 2.9 usec; r = 4.7 usec; ur = 4.7 usec x86_64: AMD Opteron 246, 1994 MHz, 3971.48 bogomips // TODO ppc64: POWER5 (gr), 1656 MHz (SMT disabled, 1 virtual CPU per physical CPU) // TODO TODO  Systemtap：基于探针的检测工具，提供简化的编程接口。SystemTap 已经支持内核探针。还可以利用 Uprobes 。 支持其他 CPU 架构  Uprobes 团队 下面的成员对 Uprobes 作出了主要的贡献：\n Jim Keniston - jkenisto@us.ibm.com Ananth Mavinakayanahalli - ananth@in.ibm.com Prasanna Panchamukhi - prasanna@in.ibm.com Dave Wilder - dwilder@us.ibm.com  Uprobes 例子 这儿有份内核模块样本，展示 Uprobes 的用法，统计在特定地址的指令执行了多少次，以及可选的（除非 verbose=0）输出每次执行。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59  /* uprobe_example.c */ #include \u0026lt;linux/module.h\u0026gt;#include \u0026lt;linux/kernel.h\u0026gt;#include \u0026lt;linux/init.h\u0026gt;#include \u0026lt;linux/uprobes.h\u0026gt; /* * Usage: insmod uprobe_example.ko pid=\u0026lt;pid\u0026gt; vaddr=\u0026lt;address\u0026gt; [verbose=0] * where \u0026lt;pid\u0026gt; identifies the probed process and \u0026lt;address\u0026gt; is the virtual * address of the probed instruction. */ static int pid = 0; module_param(pid, int, 0); MODULE_PARM_DESC(pid, \u0026#34;pid\u0026#34;); static int verbose = 1; module_param(verbose, int, 0); MODULE_PARM_DESC(verbose, \u0026#34;verbose\u0026#34;); static long vaddr = 0; module_param(vaddr, long, 0); MODULE_PARM_DESC(vaddr, \u0026#34;vaddr\u0026#34;); static int nhits; static struct uprobe usp; static void uprobe_handler(struct uprobe *u, struct pt_regs *regs) { nhits++; if (verbose) printk(KERN_INFO \u0026#34;Hit #%d on probepoint at %#lx\\n\u0026#34;, nhits, u-\u0026gt;vaddr); } int __init init_module(void) { int ret; usp.pid = pid; usp.vaddr = vaddr; usp.handler = uprobe_handler; printk(KERN_INFO \u0026#34;Registering uprobe on pid %d, vaddr %#lx\\n\u0026#34;, usp.pid, usp.vaddr); ret = register_uprobe(\u0026amp;usp); if (ret != 0) { printk(KERN_ERR \u0026#34;register_uprobe() failed, returned %d\\n\u0026#34;, ret); return -1; } return 0; } void __exit cleanup_module(void) { printk(KERN_INFO \u0026#34;Unregistering uprobe on pid %d, vaddr %#lx\\n\u0026#34;, usp.pid, usp.vaddr); printk(KERN_INFO \u0026#34;Probepoint was hit %d times\\n\u0026#34;, nhits); unregister_uprobe(\u0026amp;usp); } MODULE_LICENSE(\u0026#34;GPL\u0026#34;);   你可以用下面的 Makefile 编译内核模块 uprobe_example.ko：\n1 2 3 4 5 6 7 8  obj-m := uprobe_example.o KDIR := /lib/modules/$(shell uname -r)/build PWD := $(shell pwd) default: $(MAKE) -C $(KDIR) SUBDIRS=$(PWD) modules clean: rm -f *.mod.c *.ko *.o .*.cmd rm -rf .tmp_versions   例如，如果你想要运行 myprog ，然后监控 myfunc() 的调用情况，你可以这样做：\n1 2 3 4 5 6 7 8 9 10 11 12 13  $ make\t// Build the uprobe_example module. ... $ nm -p myprog | awk \u0026#39;$3==\u0026#34;myfunc\u0026#34;\u0026#39; 080484a8 T myfunc $ ./myprog \u0026amp; $ ps PID TTY TIME CMD 4367 pts/3 00:00:00 bash 8156 pts/3 00:00:00 myprog 8157 pts/3 00:00:00 ps $ su - ... # insmod uprobe_example.ko pid=8156 vaddr=0x080484a8   每次调用 myfunc() 函数，将会在 /var/log/messages 文件中和终端上，看到这种信息：\u0026ldquo;kernel: Hit #1 on probepoint at 0x80484a8\u0026rdquo;。要关闭探测，就移除模块：\n1  # rmmod uprobe_example   将会在 /var/log/messages 文件中和终端上看见这种信息：\u0026ldquo;Probepoint was hit 5 times\u0026rdquo;。\nUretprobes 例子 这是展示 return 探针用法的内核模块样本，输出函数的返回值。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87  /* uretprobe_example.c */ #include \u0026lt;linux/module.h\u0026gt;#include \u0026lt;linux/kernel.h\u0026gt;#include \u0026lt;linux/init.h\u0026gt;#include \u0026lt;linux/uprobes.h\u0026gt;#include \u0026lt;linux/ptrace.h\u0026gt; /* * Usage: * insmod uretprobe_example.ko pid=\u0026lt;pid\u0026gt; func=\u0026lt;addr\u0026gt; [verbose=0] * where \u0026lt;pid\u0026gt; identifies the probed process, and \u0026lt;addr\u0026gt; is the virtual * address of the probed function. */ static int pid = 0; module_param(pid, int, 0); MODULE_PARM_DESC(pid, \u0026#34;pid\u0026#34;); static int verbose = 1; module_param(verbose, int, 0); MODULE_PARM_DESC(verbose, \u0026#34;verbose\u0026#34;); static long func = 0; module_param(func, long, 0); MODULE_PARM_DESC(func, \u0026#34;func\u0026#34;); static int ncall, nret; static struct uprobe usp; static struct uretprobe rp; static void uprobe_handler(struct uprobe *u, struct pt_regs *regs) { ncall++; if (verbose) printk(KERN_INFO \u0026#34;Function at %#lx called\\n\u0026#34;, u-\u0026gt;vaddr); } static void uretprobe_handler(struct uretprobe_instance *ri, struct pt_regs *regs) { nret++; if (verbose) printk(KERN_INFO \u0026#34;Function at %#lx returns %#lx\\n\u0026#34;, ri-\u0026gt;rp-\u0026gt;u.vaddr, regs_return_value(regs)); } int __init init_module(void) { int ret; /* Register the entry probe. */ usp.pid = pid; usp.vaddr = func; usp.handler = uprobe_handler; printk(KERN_INFO \u0026#34;Registering uprobe on pid %d, vaddr %#lx\\n\u0026#34;, usp.pid, usp.vaddr); ret = register_uprobe(\u0026amp;usp); if (ret != 0) { printk(KERN_ERR \u0026#34;register_uprobe() failed, returned %d\\n\u0026#34;, ret); return -1; } /* Register the return probe. */ rp.u.pid = pid; rp.u.vaddr = func; rp.handler = uretprobe_handler; printk(KERN_INFO \u0026#34;Registering return probe on pid %d, vaddr %#lx\\n\u0026#34;, rp.u.pid, rp.u.vaddr); ret = register_uretprobe(\u0026amp;rp); if (ret != 0) { printk(KERN_ERR \u0026#34;register_uretprobe() failed, returned %d\\n\u0026#34;, ret); unregister_uprobe(\u0026amp;usp); return -1; } return 0; } void __exit cleanup_module(void) { printk(KERN_INFO \u0026#34;Unregistering probes on pid %d, vaddr %#lx\\n\u0026#34;, usp.pid, usp.vaddr); printk(KERN_INFO \u0026#34;%d calls, %d returns\\n\u0026#34;, ncall, nret); unregister_uprobe(\u0026amp;usp); unregister_uretprobe(\u0026amp;rp); } MODULE_LICENSE(\u0026#34;GPL\u0026#34;);   像在上面的 uprobe 例子那样编译内核模块。\n1 2 3 4 5 6 7 8 9 10 11  $ nm -p myprog | awk ‘$3==\u0026#34;myfunc\u0026#34;’ 080484a8 T myfunc $ ./myprog \u0026amp; $ ps PID TTY TIME CMD 4367 pts/3 00:00:00 bash 9156 pts/3 00:00:00 myprog 9157 pts/3 00:00:00 ps $ su - … # insmod uretprobe_example.ko pid=9156 func=0x080484a8   在 /var/log/messages 文件中和终端上，会看到如下信息：\n1 2  kernel: Function at 0x80484a8 called kernel: Function at 0x80484a8 returns 0x3   移除模块关闭探测：\n1  # rmmod uretprobe_example   在 /var/log/messages 文件中和终端上，会看到信息：\u0026ldquo;73 calls, 73 returns\u0026rdquo;。\n","description":"","id":3,"section":"posts","tags":["uprobe","trace"],"title":"译｜2008｜User-Space Probes (Uprobes)","uri":"https://jayce.github.io/public/posts/trace/user-space-probes/"},{"content":"译者序 这篇文章翻译自 Linux 内核源码树中的 kprobes.txt 文件，此文件描述了 Kprobes 的概念、工作原理、限制等内容。因为文件的最后一次提交是在 2019 年，所以文章标题中的年份也就是指这个意思的。\n下面的表格是对关键词的一点解释，概念其实就这几个。\n   关键词 解释     Kprobes 指的是内核的探测机制、框架，依赖于硬件的特定功能实现的，比如 int3 指令   kprobe 指的是 Kprobes 的对象或结构体，关联探测点和探针   probepoint 探测点，一个可用于观察、监视目的的具体位置，比如：一个函数的入口、返回地址   probe 探针，在探测点做具体事情的对象，比如：分析、追踪    如果用一句话解释 Kprobes 原理就是：Kprobes 在探测点上注册了一些探针，当 CPU 执行到探测点的时候 Kprobes 会调用所有相关探针的回调函数。CPU 是怎么从执行流转到 Kprobes 的呢？\n注：因为水平有限，文中难免存在遗漏或者错误的地方。如有疑问，建议直接阅读原文。\n概念： Kprobes 和 Return Probes Kprobes 能够让你动态的介入内核的任意函数，且无中断的收集调试和性能信息。基本上，你可以捕获内核的任意地址1，指定一个在断点命中候调用回调函数。\n目前，探针有两种类型：kprobes ，kretprobes（也被称为 return 探针）。基本上， kprobe 可以安插到任意指令上。当一个指定的函数返回时触发 return 探针。\n通常，基于 Kprobes 的探测工具被打包成了一个内核模块。模块的初始化函数会安装（注册）一个或多个探针，而模块的卸载函数会注销它们。 register_kprobe() 注册函数指明探针要插入到什么位置，探针命中的时候要调用什么样的函数。\n也有一些用来批量注销或注册一组探针的 register_/unregister_*probes() 函数。在必须一次性注销大量探针的时候，这些函数可以加快注销过程。\n接下来的四个小节会解释不同类型的探针及跳转优化是如何工作的。这些内容讲了一些必须要知道的事项，以便充分利用 Kprobes ，例如： pre_handler 与 post_handler 之间的区别，以及如何使用 kretprobes 的 maxactive 、 nmissed 字段。不过，假如你想马上试试 Kprobes 的话，可以直接跳至[##支持的架构]章节。\nKprobe 如何工作？ Kprobes 在注册了一个 kprobe 后，复制被探测的指令，并且把被探测指令的第一个字节替换为断点指令（例如：在 i386、x86_64 平台上的 int3）。\n在 CPU 命中断点指令时，会发生一个 trap，CPU 的寄存器会被保存，而控制通过 notifier_call_chain 机制转移到 Kprobes 。Kprobes 执行与 kprobe 关联的 pre_handler，并且向它传递 kprobe 结构体和保存的寄存器地址。\n接着，Kprobes 单步执行被探测指令的副本。（虽然单步执行原始指令会更简单，但过后 Kprobes 还必须移除断点指令。当另一个 CPU 执行过探测点的时候，将会打开一个小的时间窗口。）\n在指令单步执行完之后，Kprobes 会执行与 kprobe 关联的 post_handler，如果有的话。然后，继续执行探测点之后的指令。\n改变执行路径 kprobes 能够探测一段正在运行的内核代码，因此它能改变寄存器，包括指令指针。类似保存栈帧、恢复执行路径，这类操作需要非常地小心，因为 kprobes 作用在正在运行的内核上面，需要深入的了解计算结构体系和并行计算才行。\n假如你在 pre_handler 回调函数内改变指令指针（以及设置其它相关的寄存器），那你必须返回非零值，好让 kprobes 停止单步执行并立即返回到指定地址。这也表示 post_handler 不应该再被调用。\n注意，在那些使用 TOC （目录）进行函数调用的架构上，这种操作可能会更困难，因为你必须在你的模块中为你的函数设置新的 TOC，并且在函数返回之后还要恢复先前的 TOC。\nReturn 探针 Return 探针如何工作的？ 在你调用 register_kretprobe() 函数的时候， Kprobes 会在函数的入口处建立一个 kprobe。在调用被探测函数的时候命中这个探针， Kprobes 会保存 return 地址的一个副本，且用一个 “trampoline”（蹦床）的地址替换 return 地址。trampoline 是一段任意的代码 — 通常只是 nop 指令。在启动的时候， Kprobes 在蹦床注册了一个 kprobe。\n在被探测的函数执行 return 指令时，控制转移到蹦床命中探针。 Kprobes 的蹦床处理函数调用与 kretprobe 关联的用户指定的回调函数，然后把保存的指令指针设置为保存的 return 地址，一旦从 trap 返回，执行会在这里恢复。\n在被探测的函数执行期间，它的返回地址被保存在一个 kretprobe_instance 类型的对象中。在调用 register_kretprobe() 函数前，用户设置 kretprobe 结构体的 maxactive 字段表示可同时探测指定函数的实例数量。 register_kretprobe() 函数会预先分配规定数量的 kretprobe_instance 对象。\n例如，假设该函数是非递归的，且在自旋锁锁住的情况下被调用，那 maxactive 的值为 1 应该足够。如果函数是非递归的，且永远不放弃 CPU （例如：通过信号量或抢占），那 NR_CPUS 应该足够。要是 maxactive 的值小于等于零的话，会设置成默认值。如果开启 CONFIG_PREEMPT 选项，默认值为 max(10, 2*NR_CPUS)（在两倍的 CPU 数量与 10 之间取较大的值）。其他情况，默认值为 NR_CPUS（CPU 数量）。\n如果你把 maxactive 设置的很小的话，也不会有什么问题，只是会漏掉一些探针而已。在 kretprobe 结构体中，return 探针注册后 nmissed 字段会设置为 0，之后在每次进入被探测函数且没有可用的 kretprobe_instance 对象关联 return 探测的时候累加。\nKretprobe 入口回调函数 Kretprobes 还提供一个可选的用户回调函数，它运行于函数入口。这个回调函数通过 kretprobe 结构体 entry_handler 字段指定。每当命中放置在函数入口处的 kprobe 时，就会调用用户自定义的 entry_handler 函数。如果 entry_handler 函数返回零（成功），那么对应的 return 回调函数保证会在函数返回的时候被调用。如果 entry_handler 返回一个非零错误， Kprobes 会保留返回地址，而 kretprobe 对特定的函数实例没有影响。\n使用与它们关联的唯一对象 kretprobe_instance，可以匹配许多的 entry 和 return 回调函数调用。另外，用户也可以把每个 return-instace 的私有数据指定为每个 kretprobe_instance 对象的一部分。这在 entry 和 return 回调函数之间共享私有数据时尤其有用。每个私有数据对象的大小可以在 kretprobe 注册时通过 kretprobe 结构体中的 data_size 字段指定。私有数据可以通过每个 kretprobe_instance 对象的 data 字段访问。\n如果已经进入被探测函数但没有可用的 kretprobe_instance 对象，那么除了增加 nmissed 的计数之外，还会跳过 entry_handler 调用。\n跳转优化如何工作的？ 如果内核使用 CONFIG_OPTPROBES=y （x86/x86-64、非抢占式内核上该标记自动地设置为 y）编译，且内核参数 “debug.kprobes_optimization” 设置为 1 （见 sysctl(8) ），那么 Kprobes 尝试在每个探测点用 jump 指令代替 breakpoint 指令来减少命中探针的开销。\n初始化 Kprobe 在注册了一个探针试图优化之前，Kprobes 会在指定的地址插入一个普通的，基于断点的 kprobe。所以，即便不能优化这个特定的探测点，也会有一个探针在那儿。\n安全检查 在进行优化探针之前，Kprobes 会做以下安全检查：\n  Kprobes 校验会被 jump 指令替换的区域（”已优化的区域“）完全处于一个函数内部。（jump 指令是多字节指令，因此可能会覆盖多个指令）\n  Kprobes 分析整个函数，并且确认不会跳入已优化的区域。特别是：\n 该函数不包含间接跳转 该函数不包含引起异常的指令（因为被异常触发的固定代码可能会跳回到已优化的区域 — Kprobes 会检查异常表来验证这一点） 该函数附近没有跳转到已优化的区域（除了第一个字节）    对于已优化区域中的每一个指令，Kprobes 会验证它们能否离线执行。\n  准备 detour 缓冲区  detour 意思是像交通节点（环岛）那样\n 接着，Kprobes 准备一个“环形”缓冲区，包含以下指令序列：\n 推进 CPU 寄存器的代码（模拟断点 trap） 调用蹦床代码，再间接调用用户的探针回调函数 恢复寄存器的代码 优化区域的指令 跳回原始执行路径的指令  优化前 在准备 detour 缓冲区后， Kprobes 会检查确保不出现以下情况：\n 探针有一个 post_handler 回调函数 在优化区域中的其他指令被探测了 已禁用的探针  在上述任何一种情况下，Kprobes 都不会优化探针。因为这都是临时情况，如果情况有变化，Kprobes 会再次进行优化。\n如果 kprobe 可以被优化，Kprobes 会把 kprobe 列入优化队列中，然后启动工作队列 kprobe-optimizer 去优化它。如果被优化的 probepoint 在优化之前命中， Kprobes 通过把 CPU 的指令指针设置为 detour 缓冲区中被复制的代码，将控制权返回到原始指令路径 — 这样做至少避免了单步执行。\n优化 Kprobe-optimizer 并不会立即插入 jump 指令，相反为了安全它会先调用 synchronize_rcu() 函数，因为在处理优化区域的过程中 CPU 可能会被中断 2。如你所知， synchronize_rcu() 函数可以确保所有活跃的中断在调用 synchronize_rcu() 的时候已经完成，但前提是 CONFIG_PREEMPT=n 的时候。所以，kprobe 的优化版本只支持 CONFIG_PREEMPT=n 的内核 3。\n之后， Kprobe-optimizer 调用 stop_machine() 函数替换优化区域，用一个跳转到 detour 缓冲区指令，使用 text_poke_smp() 函数。\n取消优化 当优化的 kprobe 被其他 kprobe 注销、禁用或阻塞的时候，它将不会被优化。如果这种情况在优化完成之前发生，则只是将 kprobe 从优化队列中移除。如果优化已经完成，会通过调用 text_poke_smp() 函数把 jump 指令替换为原始代码（除了第一个字节中的 int3 断点）。\nip and returning 1. However, when the probe is optimized, that `modification` is ignored. `Thus`, if you want to `tweak` the kernel’s execution path, you need to `suppress` optimization, using one of the following techniques: * Specify an empty function for the kprobe’s post_handler. or * Execute ‘sysctl -w debug.kprobes_optimization=n’ -- geeks 注意：\n跳转优化改变了 kprobe 的 pre_handler 的行为。优化前，pre_handler 通过改变 regs-\u0026gt;ip 的同时返回 1 可以改变内核的执行路径。然而，在 probe 被优化的时候，修改会被忽略。因此，如果你想微调内核的执行路径，需要使用一个方法去抑制优化：\n 给 kprobe 的 post_handler 指定一个空函数 执行 sysctl -w debug.kprobes_optimization=n 命令  黑名单 Kprobes 可以探测除自身以外的大部分内核空间。这表示有一些函数 kprobes 无法探测。探测（trapping）这样的函数会导致递归 trap （比如：双重故障）或者嵌套的 probe 回调函数可能永远不会被调用。如果你想添加一个函数到黑名单中，只需要两个步骤：首先，引入 linux/kprobes.h 文件；其次，使用 NOKPROBE_SYMBOL() 宏指定一个要被列入黑名单的函数。 Kprobes 对照黑名单检查传入的 probe 地址，如果传入的地址在黑名单中会拒绝注册。\n支持的架构 Kprobes 和 Kretprobes 已在下面的这些结构体系上实现：\n i386 (Supports jump optimization)（支持跳转优化） x86_64 (AMD-64, EM64T) (Supports jump optimization)（支持跳转优化） ppc64 ia64 (Does not support probes on instruction slot1.)（在 slot1 指令上不支持 probes） sparc64 (Return probes not yet implemented.)（返回 probes 还没实现） arm ppc mips s390 parisc  配置 Kprobes 在使用 make menuconfig/xconfig/oldconfig 配置内核时，确保 CONFIG_KPROBES  设置为 “y”。在 “General setup” 字符后搜索 “Kprobes”。\n为了可以加载和卸载基于 Kprobes 的探测模块，请确保将“支持模块加载”（CONFIG_MODULES）和“模块卸载”（CONFIG_MODULE_UNLOAD）设置为 “y”。\n还要确保将 CONFIG_KALLSYMS  甚至是 CONFIG_KALLSYMS_ALL 都设置为 “y”，因为 kallsyms_lookup_name() 函数被内核里的 kprobe 地址解析代码使用。\n如果你需要在函数中间插入 probe，也许发现“使用 debug info 编译内核” (CONFIG_DEBUG_INFO) 非常有用，因此可以使用 objdump -d -l vmlinux 命令去查看源码到目标代码的映射关系。\nAPI 参考 Kprobes API 为每种探针类型提供了一个”注册“和“注销”函数。还包括批量注册、注销探针的 register_*probes 和 unregister_*probes 函数。这有些迷你手册以及将会用到的相关的探针回调函数的简短说明。相关例子，可查看在 samples/kprobes/ 子目录内的文件。\nregister_kprobe 1 2  #include \u0026lt;linux/kprobes.h\u0026gt;int register_kprobe(struct kprobe *kp);   addr. When the breakpoint is hit, Kprobes calls kp-pre_handler. After the probed instruction is single-stepped, Kprobe calls kp-post_handler. If a fault occurs during execution of kp-pre_handler or kp-post_handler, or during single-stepping of the probed instruction, Kprobes calls kp-fault_handler. Any or all handlers can be NULL. If kp-flags is set KPROBE_FLAG_DISABLED, that kp will be registered but disabled, so, its handlers aren’t hit until calling enable_kprobe(kp). -- 在 kp-\u0026gt;addr 地址设置一个断点。命中断点时，Kprobes 调用 kp-\u0026gt;pre_handler。在探测的指令单步执行后，Kprobe 调用 kp-\u0026gt;post_handler。如果一个错误发生，在执行 kp-\u0026gt;pre_handler 或 kp-\u0026gt;post_handler 期间，又或者是在单步执行被探测指令期间，Kprobes 会调用 kp-\u0026gt;fault_handler。所有回调函数都可以是 NULL。如果 kp-\u0026gt;flags 设置为 KPROBE_FLAG_DISABLED ，kp 将会被注册且处于禁用状态。所以 kp 的回调函数在调用 enable_kprobe(kp) 之前不会被调用。\n注意：\n  通过引入 symbol_name 字段来构造 kprobe，探测点地址解析将会由内核来处理。可以使用以下内容：\nkp.symbol_name = \u0026quot;symbol_name\u0026quot;;\n（64 位 powepc 错综复杂，例如透明地处理函数描述符）\n  如果在符号中用于安装探测点的偏移量是已知的，请使用 kprobes 结构体的 offset 字段。这个字段用于计算探测点。\n  kprobe 的 symbol_name 或者 addr 字段都被指定，kprobe 注册会失败且返回 EINVAL。\n  使用 CISC 架构（如：i386，x86_64），kprobes 代码不会验证，如果 kprobe.addr 在指令边界。谨慎使用 offset。\n  register_kprobe() 函数成功返回 0，其他情况返回一个负的 errno。\n用户的 pre-handler（kp-\u0026gt;pre_handler）函数原型:\n1 2 3  #include \u0026lt;linux/kprobes.h\u0026gt;#include \u0026lt;linux/ptrace.h\u0026gt;int pre_handler(struct kprobe *p, struct pt_regs *regs);   用指向与断点关联的 kprobe 指针 p 以及命中断点时保存的寄存器指针 regs 调用。\npost_handler): -- 用户的 post-handler （kp-\u0026gt;post_handler）函数原型：\n1 2 3 4  #include \u0026lt;linux/kprobes.h\u0026gt;#include \u0026lt;linux/ptrace.h\u0026gt;void post_handler(struct kprobe *p, struct pt_regs *regs, unsigned long flags);   p 和 regs 同 pre_handler 所述。flags 看起来一直是 0。\nfault_handler): -- 用户的 fault-handler （kp-\u0026gt;fault_handler）函数原型：\n1 2 3  #include \u0026lt;linux/kprobes.h\u0026gt;#include \u0026lt;linux/ptrace.h\u0026gt;int fault_handler(struct kprobe *p, struct pt_regs *regs, int trapnr);   p 和 regs 同 pre_handler 所述 。 trapnr 是故障相关的特定架构下的 trap 号（例如：在 i386 上， 13 为普通防护故障，14 为页面故障）。如果成功的处理了异常返回 1。\nregister_kretprobe 1 2  #include \u0026lt;linux/kprobes.h\u0026gt;int register_kretprobe(struct kretprobe *rp);   kp.addr. When that function returns, Kprobes calls rp-handler. You must set rp-maxactive `appropriately` before you call register_kretprobe(); see “How Does a Return Probe Work?” for details. register_kretprobe() returns 0 on success, or a negative errno otherwise. -- 为 rp-\u0026gt;kp.addr 地址的函数建立一个 return 探针。在函数返回时，kprobes 调用 rp-\u0026gt;handler 。在调用 register_kretprobe() 之前必须设置合适的 rp-\u0026gt;maxactive，细节参考 “Return Probe 如何工作？” 。\nregister_kretprobe() 成功返回 0，其他情况返回一个负的 errno。\nhandler): -- 用户的 return 探针回调函数（rp-\u0026gt;handler）原型：\n1 2 3 4  #include \u0026lt;linux/kprobes.h\u0026gt;#include \u0026lt;linux/ptrace.h\u0026gt;int kretprobe_handler(struct kretprobe_instance *ri, struct pt_regs *regs);   regs 同 kprobe.pre_handler 描述那样。ri 指向 kretprobe_instance 对象，其中可能涉及以下字段：\n ret_addr：返回地址 rp：指向相关的 kretprobe 对象 task：指向相关的 task 结构体 data：指向每个 return-instace 私有数据，细节参考 “kretprobe entry-handler”。  regs_return_value(regs) 宏提供一个简单的抽象方法，从架构的 ABI 定义的合适的寄存器中提取返回值。\n目前，回调函数的返回值是被忽略的。\nunregister_*probe 1 2 3  #include \u0026lt;linux/kprobes.h\u0026gt;\tvoid unregister_kprobe(struct kprobe *kp); void unregister_kretprobe(struct kretprobe *rp);   移除探针。注销函数可以在探针被注册后调用。\n注意：\n如果这些发现一个不正确的探针（不包括未注册的探针），它们会清除探针的 addr 字段。\nregister_*probes 1 2 3  #include \u0026lt;linux/kprobes.h\u0026gt;int register_kprobes(struct kprobe **kps, int num); int register_kretprobes(struct kretprobe **rps, int num);   注册数组中 num 个探针。如果在注册期间发生错误，在 register_*probes 函数返回之前会安全地注销数组中已注册的探针，直到发生错误的探针为止。\n kps/rps：指向 *probe 数据结构的指针数组 num：数组的大小  注意：\n必须分配（或定义）指针数组，且在使用这些函数之前设置数组的所有元素。\nunregister_*probes 1 2 3  #include \u0026lt;linux/kprobes.h\u0026gt;void unregister_kprobes(struct kprobe **kps, int num); void unregister_kretprobes(struct kretprobe **rps, int num);   一次性移除指定数组中 num 个探针。\n注意：\n如果这些函数在数组中发现一些不正确的探针（比如：未注册的探针），会清除那些不正确探针的 addr 字段。数组中其他的探针会被注销掉。\ndisable_*probe 1 2 3  #include \u0026lt;linux/kprobes.h\u0026gt;int disable_kprobe(struct kprobe *kp); int disable_kretprobe(struct kretprobe *rp);   临时地禁用某个探针。调用 enable_*probe() 函数可再次启用。必须是已经注册的探针。\nenable_*probe 1 2 3  #include \u0026lt;linux/kprobes.h\u0026gt;int enable_kprobe(struct kprobe *kp); int enable_kretprobe(struct kretprobe *rp);   Enables *probe which has been disabled by disable_*probe(). You must specify the probe which has been registered.\n通过 disable_*probe() 启用已经被禁用的 *probe。必须指定已经注册的 probe。\nKprobes 特性与限制 kprobes 允许在同一个地址插入多个探针。此外，带有 post_handler 的探测点无法被优化。所以，如果在已优化的探测点插入带有 post_handler 回调函数的 kprobe 探针，探测点会自动地变成未优化的。\n通常，可以在内核的任意位置插入探针。特别的是，它可以探测中断处理函数。本节讨论了已知的异常。\n如果试图在实现 Kprobes 的代码中插入一个探针，register_*probe 函数将返回 -EINVAL。（在 kernel/kprobes.c 和 arch/*/kernel/kprobes.c 文件中，还有像 do_page_fault 和 notifier_call_chain 这类的函数）。\n如果在可内联的函数中插入探针，Kprobes 并不会给所有内联实例插入探针。如果没有命中期望的探针，记住一点， gcc 可能会自动内联一个函数。\n探针回调函数可以修改被检测函数的环境 \u0026ndash; 例如，改变内核数据结构或者 pt_regs 数据结构的内容（从断点返回时恢复到寄存器中）。因此，Kprobes 可用于安装 bug 修复或测试时注入错误。当然， Kprobes 是没有办法把故意地注入的错误与意外的错误区分开。不要喝大了搞事情。\nKprobes 不会阻止探针回调函数之间的相互作用 \u0026ndash; 比如，先给 printk() 函数插入探针，接着又从另一个探针回调函数中调用 printk() 函数。如果探针回调函数命中一个探针，那么这第二个探针的回调函数不会执行，将只会累加探针的 kprobe.nmissed 值。\n自 Linux v2.6.15-rc1 开始，多个回调函数（或者相同回调函数的多个实例）可以同时在不同的 CPU 上运行。\n除了注册和注销探针之外，Kprobes 不会用互斥锁或分配内存。\n探针回调函数在禁用抢占或者禁用中断的情况下运行，这取决于架构以及优化状态（例如，kretprobe 和优化的 kprobe 回调函数在 x86/x86-64 上运行时没有禁用中断）。不管如何，你的回调函数都不应该让出 CPU （比如，试图获取信号量或等待 I/O）。\n因为 return 探针是通过把蹦床的地址替换为返回地址来实现的，所以堆栈回溯以及调用 __builtin_return_address() 函数得到的是蹦床的地址，而不是 kretprobed 函数实际 return 地址（就目前我们知道的而言，__builtin_return_address() 函数只用于测试工具和报告错误）。\n如果一个函数的调用次数不能匹配返回的次数，在那个函数上注册的探针可能产生不想要的结果。这种情况，会输出一行 kretprobe BUG!: Processing kretprobe d000000000041aa8 @ c00000000004f48c。有了这行信息，就可以关联导致问题的 kretprobe 实例。涵盖了 do_exit() 函数的情况。 do_execve() 和 do_fork() 函数都不是问题。我们不知道的其他特定的情况，可能会出现问题。\n如果在进入或者退出某个函数时，CPU 在除当前 task 以外的堆栈上运行，那在这个函数上注册 return 探针可能会产生不想要的结果。因为这个原因，Kprobes 不支持 __switch_to() 函数 x86_64 版本的 return 探针（或 kprobes），注册函数会返回 -EINVAL 。\n在 x86/x86-64 架构上，由于 Kprobes 跳转优化修改指令普遍存在，会对优化有一些限制。为解释这一点，我们引入些术语。想象一下，一个由 2 字节指令和 3 字节指令组成的 3 个指令序列。\n1 2 3 4 5 6  IA | [-2][-1][0][1][2][3][4][5][6][7] [ins1][ins2][ ins3 ] [\u0026lt;- DCR -\u0026gt;] [\u0026lt;- JTPR -\u0026gt;]   1 2 3 4 5 6  ins1: 1st Instruction ins2: 2nd Instruction ins3: 3rd Instruction IA: Insertion Address JTPR: Jump Target Prohibition Region DCR: Detoured Code Region   DCR 内的指令被复制到 kprobe 的离线缓冲区中，因为 DCR 内的字节被 5 字节 jump 指令替代了。所以，这儿会有几个限制。\n DCR 内的指令一定是可重定位的 DCR 内的指令一定不能包含 call 指令 JTPR 不能作为 jump 或 call 指令的目标 DCR 不能跨越函数之间的边界  不过，这些限制由内核的指令解码器检查，所以不需要关心这些限制。\n探针的开销 在 2005 年常见的 CPU 上，处理命中 kprobe 要花费 0.5 - 1.0 微秒。具体一点，基准测试反复命中同一个探测点，每一次触发简单的回调函数，每秒 1-2 百万次命中，具体数值取决于 CPU 架构。通常，命中 return 探针比命中 kprobe 多花费 50-75% 的时间。当你把一个 kretprobe 插入到一个函数的时候，实际是在函数入口处添加一个 kprobe，基本上上函数不会增加开销。\n下面有些不同架构开销的样本（微秒）：\nk = kprobe; r = return probe; kr = kprobe + return probe on same function i386: Intel Pentium M, 1495 MHz, 2957.31 bogomips k = 0.57 usec; r = 0.92; kr = 0.99 x86_64: AMD Opteron 246, 1994 MHz, 3971.48 bogomips k = 0.49 usec; r = 0.80; kr = 0.82 ppc64: POWER5 (gr), 1656 MHz (SMT disabled, 1 virtual CPU per physical CPU) k = 0.77 usec; r = 1.26; kr = 1.45  已优化探针开销 通常，命中已优化的 kprobe 要花费 0.07 - 0.1 微妙来处理。这是 x86 架构开销的样本（微妙）：\nk = unoptimized kprobe, b = boosted (single-step skipped), o = optimized kprobe, r = unoptimized kretprobe, rb = boosted kretprobe, ro = optimized kretprobe. i386: Intel(R) Xeon(R) E5410, 2.33GHz, 4656.90 bogomips k = 0.80 usec; b = 0.33; o = 0.05; r = 1.10; rb = 0.61; ro = 0.33 x86-64: Intel(R) Xeon(R) E5410, 2.33GHz, 4656.90 bogomips k = 0.99 usec; b = 0.43; o = 0.06; r = 1.24; rb = 0.68; ro = 0.30  TODO 1. [SystemTap](http://sourceware.org/systemtap)：给基于探针的探测工具提供了一个简单的编程接口。可以试一下 2. sparc64 架构的 kretprobe 3. 支持其他架构 4. 用户空间的探针 5. 观察点探针（在数据引用时触发）  Kprobes 例子 见 samples/kprobes/kprobe_example.c 文件\nKretprobes 例子 见 samples/kprobes/kretprobe_example.c 文件\n有关 Kprobes 的其他信息，请参考以下 URL 链接：\n http://www-106.ibm.com/developerworks/library/l-kprobes.html?ca=dgr-lnxw42Kprobe http://www.redhat.com/magazine/005mar05/features/kprobes/ http://www-users.cs.umn.edu/~boutcher/kprobes/ http://www.linuxsymposium.org/2006/linuxsymposium_procv2.pdf (pages 101-115)  已弃用的机制 现在 Jprobes 是一个不被推荐的机制。依赖它的应该迁移到其他追踪机制或使用旧的内核。请考虑把你的工具迁移到以下工具中：\n 使用 trace-event 追踪带参数的函数   trace-event 是个低开销的静态定义的事件接口（如果关闭，没有明显的开销）。你可以定义新事件，通过 ftrace 或者其他追踪工具追踪它。\n参考以下 URL 链接：\n- https://lwn.net/Articles/379903/\n- https://lwn.net/Articles/381064/\n- https://lwn.net/Articles/383362/\n  使用 ftrace 动态事件（kprobe 事件）和 perf-probe   如果你使用调试信息（CONFIG_DEBUG_INFO=y）编译你的内核，可以用 perf-probe 设置新事件去追踪它，能发现寄存器/栈被分配给了哪个本地变量或者参数。\n参考以下文档：\n- Documentation/trace/kprobetrace.rst\n- Documentation/trace/events.rst\n- tools/perf/Documentation/perf-probe.txt\n 2.6.20) the list of registered kprobes is visible under the /sys/kernel/debug/kprobes/ directory (assuming debugfs is mounted at //sys/kernel/debug). /sys/kernel/debug/kprobes/list: Lists all registered probes on the system: -- kprobes debugfs 接口 最新的内核（\u0026gt; 2.6.20），已经注册的 kprobes 列表位于 /sys/kernel/debug/kprobes/ 目录之下（假设 debugfs 被挂载到 /sys/kernel/debug 目录）。\n/sys/kernel/debug/kprobes/list：列出在系统上所有已注册的 probes：\n1 2  c015d71a k vfs_read+0x0 c03dedc5 r tcp_v4_rcv+0x0   第一列，是已插入探针的内核地址。第二列，是表示探针的类型（k - kprobe，r - kretprobe）。第三列，是指定探针的符号+偏移量（symbol+offset）。如果被探测的函数属于一个模块，那么这个模块的名字也会被列出来。随后的几列显示探针的状态。如果探针在虚拟地址上，并且地址无效（模块初始化部分，模块虚拟地址，对应的模块已经卸载），这类探针会被标记为 [GONE]。如果探针临时被禁用，会被标记为 [DISABLED]。如果探针被优化了，会被标记为 [OPTIMIZED]。如果探针是基于 ftrace 的，会被标记为 [FTRACE]。\n/sys/kernel/debug/kprobes/enabled：强制开启/关闭 kprobes。\n提供一个全局按钮，强制的开启或关闭已注册的 kprobes。默认情况下，所有 kprobes 是开启的。输出 “0” 到这个文件，所有已注册的探针会被卸载，输出 “1” 到这个文件，又重新加载。请注意，这个按钮只是卸载和加载所有 kprobes，并不会改变每个探针的禁用状态。意思是，已经禁用的探针（标记为 [DISABLED]）是不会被激活的。\nkprobes sysctl 接口 /proc/sys/debug/kprobes-optimization： kprobes 优化开关。\n在 CONFIG_OPTPROBES=y 的时候， sysctl 接口提供一个全局按钮，强制的开启或关闭跳转优化（查看跳转章节）。默认情况下，跳转优化是开启的。如果输出 “0” 到这个文件或者通过 sysctl 设置 debug.kprobes_optimization 为 0 ，所有优化的探针将会变成未优化的，而且在这之后任何新的被注册的探针都不会被优化。\n注意，这个按钮会改变优化状态。表示已优化的探针（标记为 [OPTIMIZED]）将变成未优化的（标记 [OPTIMIZED] 会被移除）。如果按钮被打开，探针将再次被优化。\n 有部分内核代码是不能被捕获的，详情见黑名单 \u0026#x21a9;\u0026#xfe0e;\n 请想象第二个指令被中断，然后优化器在中断回调函数正在运行的时候用跳转地址替换它。当中断返回到原始地址时，没有有效指令，这会导致一个意外的结果。 \u0026#x21a9;\u0026#xfe0e;\n 优化安全检查在 ksplice 用于支持 CONFIG_PREEMPT=y 内核上可以用 stop-machine 方法替换。 \u0026#x21a9;\u0026#xfe0e;\n   ","description":"","id":4,"section":"posts","tags":["kprobe","trace"],"title":"译｜2019｜Kernel Probes (Kprobes)","uri":"https://jayce.github.io/public/posts/trace/kernel-kprobes/"},{"content":"译者序 本文翻译自 2005 年在 LWN 发布的，一篇 KProbes 入门级的文章：An introduction to KProbes，当时的内核版本为 2.6.11。文中的配图是用 Omnigraffle.app 重新做了一份，顺着作者的思路走一遍。\n注：水平有限，文中难免存在遗漏或者错误的地方。如有疑问，建议直接阅读原文。\n前言 KProbes 作为 Linux 内核的一种调试机制，也可以用来监控生产系统内部的事件。你可以用它来扫除性能瓶颈、记录特定事件、追踪问题等等。 KProbes 是由 IBM 开发出来的，作为另外一种更高级的追踪工具 Dprobes 的一种底层机制。 Dprobes 添加了很多功能，包括它自己的用来编写探针处理函数的脚本语言。不过最终，只有 KProbes 被合并到标准的内核中。\n这篇文章将会描述 2.6.11.7 内核內 KProbes 的实现。 KProbes 非常依赖处理器架构的特殊功能，并且根据执行它的架构会使用略微不同的机制。后续的讨论只与 x86 架构相关。本文假设你对 x86 架构中的中断和异常处理有一定的了解。 目前， KProbes 在 ppc64、x86_64、sparc64、i386 架构上是可用的。\nkernel probe（内核探针）是一组位于某个指令地址上的处理函数。到目前为止，内核中有两种类型的探针，称作 “KProbes” 和 “JProbes”。 KProbe 由 pre-handler 和 post-handler 定义。 当 KProbe 被安装到一个特定的指令上，且指令被执行的时候， pre-handler 会在这之前执行。同样， post-handler 会在这个指令之后执行。 JProbes 用用于在运行时访问内核函数的参数。 JProbe 由 JProbe 处理函数定义，函数原型与要读取的参数的函数相同。当被探测的函数要被执行的时候，控制权会先转移到用户定义的 JProbe 处理函数，之后再将执行权转移到原始函数。 KProbes 软件包是以扩展它自身来构建用于试、追踪、记录的工具而设计的。\n 此图描述了 KProbes 的结构。在 x86 上， KProbes 利用异常处理机制修改了普通的断点、调试和一些其他的异常处理函数，以便达到自己的目的。探针的逻辑大多都是在断点和调试异常函数的上下文中完成的，它们构成了 KProbes 架构依赖层（Architecture Dependent Layer）。 KProbes Manager 是架构无关层（Architecture Independent Layer），它是用来注册和注销探针的。用户在内核模块中准备的探针处理函数通过 KProbes Manager 来注册。\n. The following data structure describes a KProbe. -- KProbes 接口 \u0026lt;linux/kprobes.h\u0026gt; 文件中定义了实现 KProbes 接口的数据结构和函数。以下数据结构描述了一个 KProbe 。\n1 2 3 4 5 6 7 8 9 10  struct kprobe { struct hlist_node hlist; /* Internal */ kprobe_opcode_t addr; /* Address of probe */ kprobe_pre_handler_t pre_handler; /* Address of pre-handler */ kprobe_post_handler_t post_handler; /* Address of post-handler */ kprobe_fault_handler_t fault_handler; /* Address of fault handler */ kprobe_break_handler_t break_handler; /* Internal */ kprobe_opcode_t opcode; /* Internal */ kprobe_opcode_t insn[MAX_INSN_SIZE]; /* Internal */ };   先谈谈注册 KProbe 。用户可通过写一个内核模块把探针插入正在运行的内核内部，内核模块实现了探针的 pre-handler 和 post-handler 函数。如果在执行探针处理函数期间发生故障，用户可通过定义 fault-handler 函数以及传递在 struct kprobe 结构中的地址来处理故障。这些处理函数的原型定义如下。\n1 2 3 4 5  typedef int (*kprobe_pre_handler_t)(struct kprobe*, struct pt_regs*); typedef void (*kprobe_post_handler_t)(struct kprobe*, struct pt_regs*, unsigned long flags); typedef int (*kprobe_fault_handler_t)(struct kprobe*, struct pt_regs*, int trapnr);   可以看到， pre-handler 和 post-handler 都能接受探针的引用以及在探针命中时保存的寄存器。这些值是可以在 pre-handler 或 post-handler 中或需要时使用，还可以在把控制权返回到后续的指令之前修改。也意味着同一个处理函数可用在多个探测位置上。 flags 参数目前还未被使用。 trapnr 参数（用于故障处理函数）包括在处理 KProbe 期间发生的异常编号。要让 KProbe 进一步处理故障，用户定义的故障回调函数可以返回 0。假如故障已经被处理，还想要探针处理函数继续执行可以返回 1。\n请注意，虽然 post-handler 是可选的，但目前探针的 pre-handler 不能为 NULL 。因为在有些情况下可能需要 post-handler，不需要 pre-handler ，所以这点被认为是一个 bug。这种情况，用户还必须定义一个 pre-handler。另外一个 bug （能让内核崩溃）跟在 ret/lret 指令上激活的探针有关。还有一个 bug 与 int3 指令上激活的探针相关。这些的问题都应该在内核的 2.6.12 发行版中被修复了。不管怎样，这些 bugs 可以轻易地避开，而对于那些想要立即使用 KProbes 又没有采用补丁的人而言，不会造成任何严重的问题。\nKProbe 注册函数定义如下：\n1 2  int register_kprobe(struct kprobe *p); int unregister_kprobe(struct kprobe *p);   注册函数接受一个 KProbe 结构体的指针。注意，注册探针的内核模块应该一直保持对这个结构体的引用直到探针被注销。由于对 KProbes 的访问已序列化，探针可以随时注册或者注销探针，探针处理函数内部除外，否则会死锁操作系统。因为，探针处理函数是在得到用来锁定 KProbes 的自旋锁之后执行。注销探针完成之前自旋锁是被锁定的，如果试图在探针处理函数内部注销探针，那将会再一次锁定自旋锁。\n目前，不能在相同的地址上放置多个探针。不过，已经有一个补丁提交到了内核邮件列表，它通过另外一个接口允许在相同的地址上注册多个探针。内核的下一个发布版本中也许会包含它。在此之前，如果已经尝试过的话， register_kprobe() 函数会返回 -EEXIST。\nJProbes 用来在运行时访问一个函数的参数。这是用一个与被探测函数原型相同的 JProbe 处理函数办到的。在运行时，执行原始函数的时候，先复制进程的上下文，再将控制权转移到 JProbe 处理函数。在 JProbe 处理函数返回期间，进程上下文（由寄存器和栈组成）会被恢复，因此在 JProbe 处理函数中对进程上下文所做的任何修改都无效。以先前保存的状态，在放置探针的地方恢复执行。JProbe 由以下结构体表示。\n1 2 3 4  struct jprobe { struct kprobe kp; kprobe_opcode_t *entry; /* user-defined JProbe handler address */ };   用户在 entry 字段设置用来处理探针的函数地址。在 kprobe 结构体中的 addr 字段应该用被访问的函数地址来填充。下面的函数用来注册或注销一个 JProbe：\n1 2  int register_jprobe(struct jprobe *p); void unregister_jprobe(struct jprobe *p);   用户编写的 JProbe 处理函数，应该在要返回的时候调用 jprobe_return() 函数而不是 return 语句。\nKProbes Manager KProbes Manager 负责注册和注销 KProbes 、 JProbes。 kernel/kprobes.c 文件实现 KProbes manager。每个探针是由一个 struct kprobe 结构体来表示的，且保存在一个用探针的目标地址来计算的 hash 表中。用 kprobe_lock 自旋锁来串行化对哈希表的访问。在注册新的探针、注销已存在的探针之前或者命中探针的时候，自旋锁都是被锁定的。这样会阻止在 SMP 机器上并行的执行这些操作。无论什么时候命中探针，探针处理函数都是在禁用中断的情况下调用的。禁用中断，是因为处理探针是个多步骤过程，涉及断点处理以及被探测指令的单步执行。没有简单的方法来保存这些操作之间的状态，因此在处理探针期间中断一直是禁用的。\nManager 是由以下这些函数构成，且附带一点对它们的简短描述。这些函数是架构无关的。同步阅读 kernel/kprobes.c 文件中的代码以及这些内容将会阐明整个实现。\nkp by calling register_kprobe() * void unregister_jprobe(struct jprobe *jp) * Unregisters the struct kprobe used by this JProbe --  void lock_kprobes(void) ：锁定 KProbes 且记录锁定它的 CPU void unlock_kprobes(void) ：解锁 KProbes 且重置已记录的 CPU struct kprobe *get_kprobe(void *addr) ：传入被探测指令的地址，从 hash 表中取回探针 int register_kprobe(struct kprobe *p) ：函数在特定的地址上注册一个探针。注册涉及在探针专用缓冲区中的探针地址处复制指令。在 x86 上，最大的指令大小是 16 个字节，因此这 16 个字节会被复制到特定的地址。然后，用 breakpoint 指令替换位于被探测地址处的指令 void unregister_kprobe(struct kprobe *p) ：注销探针。在指定地址恢复原始指令，且从哈希表中移除探针结构体 int register_jprobe(struct jprobe *jp) ：在一个函数的地址上注册一个 JProbe。 JProbes 使用 KProbes 的机制，在 KProbe 的 pre_handler 处理函数中， JProbes 保存了它自己的函数 setjmp_pre_handler，而且还在 break_handler 函数中保存了 longjmp_break_handler 函数的地址。然后，调用 register_kprobe() 函数注册 kprobe 结构体 jp-\u0026gt;kp void unregister_jprobe(struct jprobe *jp) ：注销 JProbe 使用的 kprobe 结构体  命中 KProbe 的时候发生了什么？  以上涉及处理探针的步骤都是架构相关的，由 arch/i386/kernel/kprobes.c 文件中定义的函数来处理。注册探针后，那些处于激活状态的地址包含了 breakpoint 指令（在 x86 上是 int3）。一旦执行到被探测的地址就会执行 int3 指令，也因此控制权会转到 arch/i386/kernel/traps.c 文件中的 do_int3() 函数。 do_int3() 是通过中断门调用的，所以在控制权转到这里的时候中断是被禁用的。这个函数会通知 KProbes 产生了一个中断， KProbes 会检查中断是不是由 KProbes 的注册函数设置的。如果命中的探测地址上没有探针，只会返回 0。相反，它会调用已注册的探针函数。\n命中 JProbe 的时候发生了什么？  JProbe 必须将控制权转移到另外一个函数，这函数的原型与放置探针的函数相同，然后再将控制权交给原始函数，状态与执行 JProbe 之前相同。JProbe 利用了 KProbe 使用的机制。 JProbe 不是调用用户定义的 pre-handler ，而是指定自己的 pre-handler ，名为 setjmp_pre_handler() ，而且使用了另外一个称为 break_handler 的函数。这过程有三个步骤。\n第一步，在命中断点的时候控制权转到 kprobe_handler() 函数，它会调用 JProbe 的 pre-handler 函数(setjmp_pre_handler())。在把 eip 改成用户定义函数的地址之前，这个函数会把栈和寄存器保存下来。然后，它会返回 1 让 kprobe_handler() 函数直接返回，而不像 KProbe 那样设置单步执行。在返回时，控制权转到用户定义的函数，这样就可以访问原始函数的参数。在用户定义的函数完事后，该调用 jprobe_return() 函数，而不是做普通的 return。\n第二步，jprobe_return() 函数截断当前栈帧并生成一个断点，通过 do_int3() 函数把控制权转移到 kprobe_handler() 函数。 kprobe_handler() 函数发现生成的断点地址（jprobe_handler() 函数中 int3 指令的地址）没有注册探针，但 KProbes 在当前 CPU 上处于活跃状态。它假设断点一定是 JProbes 生成的，因此调用了它先前保存的 current_kprobe break_hanlder 函数。 break_handler 函数会恢复栈以及在控制权转移到用户定义的函数和返回之前保存的寄存器。\n第三步， kprobe_handler() 函数在已设置 JProbe 的指令处设置单步执行，剩下的一系列步骤与 KProbe 相同。\n可能出现的问题 在 KProbes 处理探针的时候，有可能会出现几个问题。第一种，在 SMP 系统上并行处理几个探针。但，所有的探针都共用一个普通的哈希表，那就需要保护它们避免遭到损坏。因此， kprobe_lock 会串行化对探针的处理。\n如果探针被放置在 KProbes 代码内部会发生另外一种问题，导致 KProbes 递归调用探针处理函数。这个问题已经在 kprobe_handler() 函数中处理，它通过检查 KProbes 是否已经在当前 CPU 上运行。这种递归探针会被悄悄的禁掉，并且控制权会返回到先前的探针处理函数。\n如果正在执行 KProbes 的时候发生抢占，在处理探针期间，上下文可以切换到另外一个进程。在先前的探针完全没有处理完的时候，其它的进程可能会触发另一个探针，控制权将再一次转到 kprobe_handler() 函数。当 KProbes 发现新探针正在递归的时候，可能会撤销它。为了避免这个问题，在处理探针的期间抢占是被禁用的。\n同样地，中断被禁用，是因为断点和调试函数是通过中断门调用的，而不是陷阱门。一旦控制权转移到断点或者调试函数就会禁用中断。这些操作是在 arch/i386/kernel/traps.c 文件中做的。\n在处理探针期间可能会发生故障。如果在用户已经定义了一个故障处理函数的情况下，控制权会被转移到故障处理函数。如果用户定义的故障处理函数返回 0 ，那么这个错误由内核来处理。此外， KProbes 会假设故障已经被处理，控制权会回到探针处理函数。\n结论 KProbes 一个极好的调试、追踪工具，也可用来测量性能。开发者可以用它来追踪他们的程序在内核中的路径，以便调试。系统管理员可以用它在生产系统中追踪内核的事件。KProbes 也可以用于非关键性性能测量。不过，目前 KProbes 的实现，在处理探针的过程中引入一些延迟。延迟背后的原因是只有一个 kprobe_lock，它在 SMP 机器上串行化了探针的执行。另外一个因素是 KProbes 使用的机制，它使用多个异常去处理一个探针。异常处理是非常昂贵的操作，会导致延迟。需要在这方面展开工作，提升 SMP 的可扩展性，缩短处探针的处理时间，使得 KProbes 成为可行的性能测量工具。\n但是，KProbes 不能直接用来做这些事情。原始的状态下，用户可编写一个实现探针函数的内核模块。不过，为了更方便的使用它，必须使用更高级的工具。这种高级工具可以包含标准的探针函数，用它们来实现所要的功能，或者它们可以包含一种类似 DProbes 的脚本语言，用来生成 probe-handlers。\n相关链接  KProbes 一篇关于 KProbes 的介绍性文章，以及一些如何使用它的例子（译注：此链接已经失效） DProbes Linux 基于 KProbes 的脚本化追踪工具 Network Packet Tracing Patch 这个补丁能让 Dprobes 追踪网络数据包经过内核栈的路径 KProbes debugfs patch 这个补丁列出所有探针，它们都可以通过 debugfs 应用在任意地址上（译注：此链接已失效） SysRq key for KProbes Patch 这个补丁能够让 SysRq 键列出所有已应用的探针（译注：此链接已失效） SystemTap Linux 内核追踪工具 - 正在开发中  致谢 作者要感谢他的编辑们 Jonathan Corbet, Kalyan T.B. (HP), Siddharth Seth (IIITB) 和 Bharata B. Rao (HP) 审阅这篇文章以及给出了他们的反馈、意见、建议等等，并帮助改进这片文章。\n","description":"","id":5,"section":"posts","tags":["kprobe","trace"],"title":"译｜2005｜ An Introduction to Kprobes","uri":"https://jayce.github.io/public/posts/trace/an-introduction-to-kprobes/"}]